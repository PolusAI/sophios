from pathlib import Path
import pytest
import subprocess as sub
import sys
from unittest.mock import patch

import graphviz
import yaml

from wic import auto_gen_header
from wic.wic_types import Yaml
import wic.cli
import wic.compiler
import wic.main
import wic.utils


@pytest.mark.slow
def test_examples() -> None:
    testargs = ['wic', '--yaml', '', '--cwl_output_intermediate_files', 'True']  # ignore --yaml
    # For now, we need to enable --cwl_output_intermediate_files. See comment in compiler.py
    with patch.object(sys, 'argv', testargs):
        args = wic.cli.parser.parse_args()

    tools_cwl = wic.main.get_tools_cwl(Path('.'))
    yml_paths = wic.main.get_yml_paths(Path('examples/'))

    # First compile all of the workflows.
    for yml_path_str in yml_paths:
        yml_path = yml_paths[yml_path_str]
        # Load the high-level yaml workflow file.
        with open(yml_path, 'r') as y:
            root_yaml_tree: Yaml = yaml.safe_load(y.read())
        yaml_forest = wic.ast.read_yml_forest((yml_path_str, root_yaml_tree), {}, yml_paths, tools_cwl)
        Path('autogenerated/').mkdir(parents=True, exist_ok=True)
        with open(f'autogenerated/{Path(yml_path).stem}_tree.yml', 'w') as f:
            f.write(yaml.dump(yaml_forest[0][1]))


        rootgraph = graphviz.Digraph(name=f'cluster_{yml_path}')
        rootgraph.attr(newrank='True')
        workflow_data = wic.compiler.compile_workflow(yaml_forest[0], args, [], [rootgraph], {}, {}, tools_cwl, True, relative_run_path=True)
        recursive_data = workflow_data[0]
        sub_node_data = recursive_data[0]
        yaml_stem = sub_node_data[1]

        wic.utils.write_to_disk(recursive_data, Path('autogenerated/'), relative_run_path=True)

        # Now blindly run all workflows and (if all inputs are present) check for return code 0.
        # Workflows are first validated before runtime, so this also checks for validity.
        # NOTE: Do not use --cachedir; we want to actually test everything.
        cmd = ['cwltool', '--outdir', f'outdir/{yaml_stem}', f'autogenerated/{yaml_stem}.cwl', f'autogenerated/{yaml_stem}_inputs.yml']
        proc = sub.run(cmd, stdout=sub.PIPE, stderr=sub.STDOUT)  # Capture the output
        if not proc.returncode == 0:
            # Since some of the workflows will be subworkflows
            # (i.e. will not have all inputs), we need to check for
            # "Missing required input parameter" and only fail the
            # workflows which should have succeeded.
            missing_input = "Missing required input parameter"
            bad_format = "File has an incompatible format"
            output = proc.stdout.decode("utf-8")
            if not (missing_input in output or bad_format in output):
                print(f"Error! {yml_paths[yml_path_str]} failed!")
                print(output)
                assert proc.returncode == 0


def test_cwl_embedding_independence() -> None:
    testargs = ['wic', '--yaml', '']  # ignore --yaml
    with patch.object(sys, 'argv', testargs):
        args = wic.cli.parser.parse_args()

    tools_cwl = wic.main.get_tools_cwl(Path('.'))
    yml_paths = wic.main.get_yml_paths(Path('examples'))

    # First compile all of the workflows once.
    for yml_path_str in yml_paths:
        yml_path = yml_paths[yml_path_str]
        # Load the high-level yaml workflow file.
        with open(yml_path, 'r') as y:
            root_yaml_tree: Yaml = yaml.safe_load(y.read())
        yaml_forest = wic.ast.read_yml_forest((yml_path_str + '.yml', root_yaml_tree), {}, yml_paths, tools_cwl)
        # Write the combined workflow (with all subworkflows as children) to disk.
        Path('autogenerated/').mkdir(parents=True, exist_ok=True)
        with open(f'autogenerated/{yml_path.stem}_tree.yml', 'w') as f:
            f.write(yaml.dump(yaml_forest[0][1]))

        # NOTE: The entire purpose of parsing an entire yaml forest is so we
        # can easily access the subtrees here. (i.e. without re-walking the AST)
        yaml_forest_lst =  wic.utils.flatten_forest(yaml_forest)

        rootgraph = graphviz.Digraph(name=f'cluster_{yml_path}')
        rootgraph.attr(newrank='True')
        is_root = True
        workflow_data = wic.compiler.compile_workflow(yaml_forest[0], args, [], [rootgraph], {}, {}, tools_cwl, is_root, relative_run_path=False)
        recursive_data = workflow_data[0]
        node_data_lst = wic.utils.flatten_recursive_data(recursive_data)

        # This test doesn't need to write to disk, but useful for debugging.
        wic.utils.write_to_disk(recursive_data, Path('autogenerated/'), relative_run_path=False)

        # Now, for each subworkflow of the given root workflow, compile the
        # subworkflow again from scratch, as if it were the root workflow,
        # and check that the generated CWL is identical. In other words,
        # check that the generated CWL of a subworkflow is independent of its
        # embedding into a parent workflow.
        for sub_node_data, sub_yaml_forest in zip(node_data_lst[1:], yaml_forest_lst):
            (sub_namespaces, sub_yml_path_str, sub_cwl_embedded, sub_yaml_inputs_, sub_dollar_defs_copy, sub_dollar_calls_copy, sub_rootgraph_) = sub_node_data
            assert sub_yaml_forest[0][0] == sub_node_data[1] + '.yml'

            # NOTE: Okay, well actually we still need to pass in sub_namespaces
            # and sub_yaml_dsl_args. (sub_dollar_defs_copy and sub_dollar_calls_copy
            # may also be necessary, but at present the test passes without them.)
            # so the embedding is independent w.r.t. everything ELSE in the parent.
            # Of course, dsl_args should generally be used sparingly. The only time
            # they must be used is to pass in an explicit edge definition/reference using &.

            rootgraph_fakeroot = graphviz.Digraph(name=f'cluster_{sub_yml_path_str}')
            rootgraph_fakeroot.attr(newrank='True')
            fake_root = True
            workflow_data_fakeroot = wic.compiler.compile_workflow(sub_yaml_forest[0], args, sub_namespaces, [rootgraph_fakeroot], sub_dollar_defs_copy, sub_dollar_calls_copy, tools_cwl, fake_root, relative_run_path=False)
            sub_node_data_fakeroot = workflow_data_fakeroot[0][0]
            sub_cwl_fakeroot = sub_node_data_fakeroot[2]

            # NOTE: Relative run: paths cause this test to fail, so remove them.
            # Using namespaced filenames in a single flat directory also
            # doesn't work because the namespaces will be of different lengths.
            sub_cwl_embedded = wic.utils.recursively_delete_dict_key('run', sub_cwl_embedded)
            sub_cwl_fakeroot = wic.utils.recursively_delete_dict_key('run', sub_cwl_fakeroot)

            if not sub_cwl_embedded == sub_cwl_fakeroot:
                # Before we crash and burn, write out files for debugging.
                with open(f'{sub_yml_path_str}_forest_embedded.yml', 'w') as w:
                    w.write(yaml.dump(yaml_forest))
                with open(f'{sub_yml_path_str}_forest_fakeroot.yml', 'w') as w:
                    w.write(yaml.dump(sub_yaml_forest))
                # NOTE: Use _dot_cwl so we don't glob these files in get_tools_cwl()
                yaml_content = yaml.dump(sub_cwl_embedded, sort_keys=False, line_break='\n', indent=2)
                filename_emb = f'{sub_yml_path_str}_embedded_dot_cwl'
                with open(filename_emb, 'w') as w:
                    w.write('#!/usr/bin/env cwl-runner\n')
                    w.write(auto_gen_header)
                    w.write(''.join(yaml_content))
                yaml_content = yaml.dump(sub_cwl_fakeroot, sort_keys=False, line_break='\n', indent=2)
                filename_fake = f'{sub_yml_path_str}_fakeroot_dot_cwl'
                with open(filename_fake, 'w') as w:
                    w.write('#!/usr/bin/env cwl-runner\n')
                    w.write(auto_gen_header)
                    w.write(''.join(yaml_content))
                cmd = f'diff {filename_emb} {filename_fake} > {sub_yml_path_str}.diff'
                sub.run(cmd, shell=True)
                print(f'Error! Check {filename_emb} and {filename_fake} and {sub_yml_path_str}.diff')
            assert sub_cwl_embedded == sub_cwl_fakeroot
