from typing import Any, Dict, List, Tuple

import graphviz
import networkx as nx

KV = Dict[str, Any]
Cwl = KV
Json = KV
Yaml = KV

Tool = Tuple[str, Cwl]
Tools = Dict[str, Tool]

# To make sure input & output variables have unique names, use namespacing.
Namespace = str
Namespaces = List[Namespace]
# For now, each Namespace is a string with the following encoding:
# step_name_i = f'{yaml_stem}__step__{i + 1}__{step_key}'
# i.e. utils.step_name_str(yaml_stem, i+1, step_key)
# In the autogenerated CWL files, Namespaces are separated by triple underscores
# (i.e. namespaces_str = '___'.join(namespaces))
# so that we can later split the string back into its original Namespace strings
# (i.e. namespaces = namespaces_str.split('___'))
# This is absolutely critical to ensuring that the CWL files corresponding to
# Subworkflows are completely independent of their embedding into a parent
# Workflow. This is one of the main design criteria, so do not mess this up!!!
# In fact, you can't mess this up because of test_cwl_embedding_independence()
# (FYI, we are forced to store this info in specially encoded strings because
# the CWL schema does not allow us to add extra tags. Specially encoded strings
# are almost never the right answer, but for now I don't see any other way.)

WorkflowInputs = Dict[str, Dict[str, str]]
WorkflowInputsFile = Dict[str, Dict[str, str]]
InternalOutputs = List[str]
DollarDef = Tuple[Namespaces, str]
DollarDefs = Dict[str, DollarDef]
DollarCalls = Dict[str, DollarDef]
PluginID = int
StepName1 = str
DiGraph = Any # graphviz.DiGraph
Graph = Tuple[DiGraph, nx.DiGraph]
YamlDSLArgs = Yaml

# As mentioned above, since we cannot store extra info in CWL files, we need a
# data structure to store temporary compiler info that gets passed through the
# recursion.
# Unfortunately, since mypy does not support Algebraic Data Types (ADTs)
# we have to weaken the type of RecursiveData to Any :(
NodeData = Tuple[Namespaces, str, Cwl, WorkflowInputsFile, DollarDefs, DollarCalls, Graph]
# RecursiveData = Tuple[NodeData, List[RecursiveData]]
RecursiveData = Any
CompilerInfo = Tuple[RecursiveData, WorkflowInputs, WorkflowInputsFile, InternalOutputs, DollarDefs, DollarCalls, StepName1]

# Create a type for our Abstract Syntax Tree (AST).
# We can probably use Dict here if str is step_name_i not just yaml_stem.
# If we need to insert steps (i.e. file format conversions), that will happen
# after edge inference, so there should not be a uniqueness issue w.r.t. step
# number re-indexing.
# NOTE: This Dict is currently performing double-duty: if there is only one
# backend, it contains the subworkflows. If there are backends, it contains
# each backend. For now, these are mutually exclusive, so is should be okay.
YamlTree = Tuple[str, Yaml]
# YamlForest = Tuple(YamlTree, Dict[str, YamlForest])
YamlForest = Any