from typing import Any, Dict, List, Tuple

import graphviz

KV = Dict[str, Any]
Cwl = KV
Json = KV
Yaml = KV

Tool = Tuple[str, Cwl]
Tools = Dict[str, Tool]

# To make sure input & output variables have unique names, use namespacing.
Namespace = str
Namespaces = List[Namespace]
# For now, each Namespace is a string with the following encoding:
# step_name_i = f'{yaml_stem}__step__{i + 1}__{step_key}'
# i.e. utils.step_name_str(yaml_stem, i+1, step_key)
# In the autogenerated CWL files, Namespaces are separated by triple underscores
# (i.e. namespaces_str = '___'.join(namespaces))
# so that we can later split the string back into its original Namespace strings
# (i.e. namespaces = namespaces_str.split('___'))
# This is absolutely critical to ensuring that the CWL files corresponding to
# Subworkflows are completely independent of their embedding into a parent
# Workflow. This is one of the main design criteria, so do not mess this up!!!
# There will be unit/regression tests for this very soon...
# (FYI, we are forced to store this info in specially encoded strings because
# the CWL schema does not allow us to add extra tags. Specially encoded strings
# are almost never the right answer, but for now I don't see any other way.)

WorkflowInputs = Dict[str, Dict[str, str]]
WorkflowInputsFile = Dict[str, Tuple[str, str]]
InternalOutputs = List[str]
DollarDef = Tuple[Namespaces, str]
DollarDefs = Dict[str, DollarDef]
DollarCalls = Dict[str, DollarDef]
PluginID = int
StepName1 = str
DiGraph = Any # graphviz.DiGraph

# As mentioned above, since we cannot store extra info in CWL files, we need a
# data structure to store temporary compiler info that gets passed through the
# recursion.
CompilerInfo = Tuple[Yaml, WorkflowInputs, WorkflowInputsFile, InternalOutputs, DollarDefs, DollarCalls, PluginID, StepName1, DiGraph]
