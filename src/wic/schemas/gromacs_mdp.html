
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Molecular dynamics parameters (.mdp options) &#8212; GROMACS 2022.4 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Useful mdrun features" href="mdrun-features.html" />
    <link rel="prev" title="Force fields in GROMACS" href="force-fields.html" />
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="mdrun-features.html" title="Useful mdrun features"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="force-fields.html" title="Force fields in GROMACS"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">GROMACS 2022.4</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">User guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Molecular dynamics parameters (.mdp options)</a></li>
      </ul>
    </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">

  <section id="molecular-dynamics-parameters-mdp-options">
<h1>Molecular dynamics parameters (.mdp options)<a class="headerlink" href="#molecular-dynamics-parameters-mdp-options" title="Permalink to this headline">Â¶</a></h1>
<section id="general-information">
<span id="mdp-general"></span><h2>General information<a class="headerlink" href="#general-information" title="Permalink to this headline">Â¶</a></h2>
<p>Default values are given in parentheses, or listed first among
choices. The first option in the list is always the default
option. Units are given in square brackets. The difference between a
dash and an underscore is ignored.</p>
<p>A <a class="reference internal" href="../reference-manual/file-formats.html#mdp"><span class="std std-ref">sample mdp file</span></a> is available. This should be
appropriate to start a normal simulation. Edit it to suit your
specific needs and desires.</p>
<section id="preprocessing">
<h3>Preprocessing<a class="headerlink" href="#preprocessing" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-include">
<span class="sig-name descname"><span class="pre">include</span></span><a class="headerlink" href="#mdp-include" title="Permalink to this definition">Â¶</a></dt>
<dd><p>directories to include in your topology. Format:
<code class="docutils literal notranslate"><span class="pre">-I/home/john/mylib</span> <span class="pre">-I../otherlib</span></code></p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-define">
<span class="sig-name descname"><span class="pre">define</span></span><a class="headerlink" href="#mdp-define" title="Permalink to this definition">Â¶</a></dt>
<dd><p>defines to pass to the preprocessor, default is no defines. You can
use any defines to control options in your customized topology
files. Options that act on existing <a class="reference internal" href="../reference-manual/file-formats.html#top"><span class="std std-ref">top</span></a> file mechanisms
include</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">-DFLEXIBLE</span></code> will use flexible water instead of rigid water
into your topology, this can be useful for normal mode analysis.</p>
<p><code class="docutils literal notranslate"><span class="pre">-DPOSRES</span></code> will trigger the inclusion of <code class="docutils literal notranslate"><span class="pre">posre.itp</span></code> into
your topology, used for implementing position restraints.</p>
</div></blockquote>
</dd></dl>

</section>
<section id="run-control">
<h3>Run control<a class="headerlink" href="#run-control" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-integrator">
<span class="sig-name descname"><span class="pre">integrator</span></span><a class="headerlink" href="#mdp-integrator" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(Despite the name, this list includes algorithms that are not
actually integrators over time. <a class="reference internal" href="#mdp-value-integrator-steep"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">integrator=steep</span></code></a> and
all entries following it are in this category)</p>
<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-integrator-md">
<span id="mdp-value-integrator=md"></span><span class="sig-name descname"><span class="pre">md</span></span><a class="headerlink" href="#mdp-value-integrator-md" title="Permalink to this definition">Â¶</a></dt>
<dd><p>A leap-frog algorithm for integrating Newtonâs equations of motion.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-integrator-md-vv">
<span id="mdp-value-integrator=md-vv"></span><span class="sig-name descname"><span class="pre">md-vv</span></span><a class="headerlink" href="#mdp-value-integrator-md-vv" title="Permalink to this definition">Â¶</a></dt>
<dd><p>A velocity Verlet algorithm for integrating Newtonâs equations
of motion.  For constant NVE simulations started from
corresponding points in the same trajectory, the trajectories
are analytically, but not binary, identical to the
<a class="reference internal" href="#mdp-value-integrator-md"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">integrator=md</span></code></a> leap-frog integrator. The kinetic
energy, which is determined from the whole step velocities and
is therefore slightly too high. The advantage of this integrator
is more accurate, reversible Nose-Hoover and Parrinello-Rahman
coupling integration based on Trotter expansion, as well as
(slightly too small) full step velocity output. This all comes
at the cost off extra computation, especially with constraints
and extra communication in parallel. Note that for nearly all
production simulations the <a class="reference internal" href="#mdp-value-integrator-md"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">integrator=md</span></code></a> integrator
is accurate enough.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-integrator-md-vv-avek">
<span id="mdp-value-integrator=md-vv-avek"></span><span class="sig-name descname"><span class="pre">md-vv-avek</span></span><a class="headerlink" href="#mdp-value-integrator-md-vv-avek" title="Permalink to this definition">Â¶</a></dt>
<dd><p>A velocity Verlet algorithm identical to
<a class="reference internal" href="#mdp-value-integrator-md-vv"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">integrator=md-vv</span></code></a>, except that the kinetic energy is
determined as the average of the two half step kinetic energies
as in the <a class="reference internal" href="#mdp-value-integrator-md"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">integrator=md</span></code></a> integrator, and this thus
more accurate.  With Nose-Hoover and/or Parrinello-Rahman
coupling this comes with a slight increase in computational
cost.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-integrator-sd">
<span id="mdp-value-integrator=sd"></span><span class="sig-name descname"><span class="pre">sd</span></span><a class="headerlink" href="#mdp-value-integrator-sd" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An accurate and efficient leap-frog stochastic dynamics
integrator. With constraints, coordinates needs to be
constrained twice per integration step. Depending on the
computational cost of the force calculation, this can take a
significant part of the simulation time. The temperature for one
or more groups of atoms (<a class="reference internal" href="#mdp-tc-grps"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tc-grps</span></code></a>) is set with
<a class="reference internal" href="#mdp-ref-t"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ref-t</span></code></a>, the inverse friction constant for each group is
set with <a class="reference internal" href="#mdp-tau-t"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tau-t</span></code></a>.  The parameters <a class="reference internal" href="#mdp-tcoupl"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tcoupl</span></code></a> and <a class="reference internal" href="#mdp-nsttcouple"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nsttcouple</span></code></a>
are ignored. The random generator is initialized with
<a class="reference internal" href="#mdp-ld-seed"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ld-seed</span></code></a>. When used as a thermostat, an appropriate value
for <a class="reference internal" href="#mdp-tau-t"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tau-t</span></code></a> is 2 ps, since this results in a friction that
is lower than the internal friction of water, while it is high
enough to remove excess heat NOTE: temperature deviations decay
twice as fast as with a Berendsen thermostat with the same
<a class="reference internal" href="#mdp-tau-t"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tau-t</span></code></a>.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-integrator-bd">
<span id="mdp-value-integrator=bd"></span><span class="sig-name descname"><span class="pre">bd</span></span><a class="headerlink" href="#mdp-value-integrator-bd" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An Euler integrator for Brownian or position Langevin dynamics,
the velocity is the force divided by a friction coefficient
(<a class="reference internal" href="#mdp-bd-fric"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">bd-fric</span></code></a>) plus random thermal noise (<a class="reference internal" href="#mdp-ref-t"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ref-t</span></code></a>). When
<a class="reference internal" href="#mdp-bd-fric"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">bd-fric</span></code></a> is 0, the friction coefficient for each particle
is calculated as mass/ <a class="reference internal" href="#mdp-tau-t"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tau-t</span></code></a>, as for the integrator
<a class="reference internal" href="#mdp-value-integrator-sd"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">integrator=sd</span></code></a>. The random generator is initialized
with <a class="reference internal" href="#mdp-ld-seed"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ld-seed</span></code></a>.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-integrator-steep">
<span id="mdp-value-integrator=steep"></span><span class="sig-name descname"><span class="pre">steep</span></span><a class="headerlink" href="#mdp-value-integrator-steep" title="Permalink to this definition">Â¶</a></dt>
<dd><p>A steepest descent algorithm for energy minimization. The
maximum step size is <a class="reference internal" href="#mdp-emstep"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">emstep</span></code></a>, the tolerance is
<a class="reference internal" href="#mdp-emtol"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">emtol</span></code></a>.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-integrator-cg">
<span id="mdp-value-integrator=cg"></span><span class="sig-name descname"><span class="pre">cg</span></span><a class="headerlink" href="#mdp-value-integrator-cg" title="Permalink to this definition">Â¶</a></dt>
<dd><p>A conjugate gradient algorithm for energy minimization, the
tolerance is <a class="reference internal" href="#mdp-emtol"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">emtol</span></code></a>. CG is more efficient when a steepest
descent step is done every once in a while, this is determined
by <a class="reference internal" href="#mdp-nstcgsteep"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstcgsteep</span></code></a>. For a minimization prior to a normal mode
analysis, which requires a very high accuracy, GROMACS should be
compiled in double precision.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-integrator-l-bfgs">
<span id="mdp-value-integrator=l-bfgs"></span><span class="sig-name descname"><span class="pre">l-bfgs</span></span><a class="headerlink" href="#mdp-value-integrator-l-bfgs" title="Permalink to this definition">Â¶</a></dt>
<dd><p>A quasi-Newtonian algorithm for energy minimization according to
the low-memory Broyden-Fletcher-Goldfarb-Shanno approach. In
practice this seems to converge faster than Conjugate Gradients,
but due to the correction steps necessary it is not (yet)
parallelized.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-integrator-nm">
<span id="mdp-value-integrator=nm"></span><span class="sig-name descname"><span class="pre">nm</span></span><a class="headerlink" href="#mdp-value-integrator-nm" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Normal mode analysis is performed on the structure in the <a class="reference internal" href="../reference-manual/file-formats.html#tpr"><span class="std std-ref">tpr</span></a>
file.  GROMACS should be compiled in double precision.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-integrator-tpi">
<span id="mdp-value-integrator=tpi"></span><span class="sig-name descname"><span class="pre">tpi</span></span><a class="headerlink" href="#mdp-value-integrator-tpi" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Test particle insertion. The last molecule in the topology is
the test particle. A trajectory must be provided to <code class="docutils literal notranslate"><span class="pre">mdrun</span>
<span class="pre">-rerun</span></code>. This trajectory should not contain the molecule to be
inserted. Insertions are performed <a class="reference internal" href="#mdp-nsteps"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nsteps</span></code></a> times in each
frame at random locations and with random orientiations of the
molecule. When <a class="reference internal" href="#mdp-nstlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstlist</span></code></a> is larger than one,
<a class="reference internal" href="#mdp-nstlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstlist</span></code></a> insertions are performed in a sphere with radius
<a class="reference internal" href="#mdp-rtpi"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rtpi</span></code></a> around a the same random location using the same
pair list. Since pair list construction is expensive,
one can perform several extra insertions with the same list
almost for free. The random seed is set with
<a class="reference internal" href="#mdp-ld-seed"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ld-seed</span></code></a>. The temperature for the Boltzmann weighting is
set with <a class="reference internal" href="#mdp-ref-t"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ref-t</span></code></a>, this should match the temperature of the
simulation of the original trajectory. Dispersion correction is
implemented correctly for TPI. All relevant quantities are
written to the file specified with <code class="docutils literal notranslate"><span class="pre">mdrun</span> <span class="pre">-tpi</span></code>. The
distribution of insertion energies is written to the file
specified with <code class="docutils literal notranslate"><span class="pre">mdrun</span> <span class="pre">-tpid</span></code>. No trajectory or energy file is
written. Parallel TPI gives identical results to single-node
TPI. For charged molecules, using PME with a fine grid is most
accurate and also efficient, since the potential in the system
only needs to be calculated once per frame.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-integrator-tpic">
<span id="mdp-value-integrator=tpic"></span><span class="sig-name descname"><span class="pre">tpic</span></span><a class="headerlink" href="#mdp-value-integrator-tpic" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Test particle insertion into a predefined cavity location. The
procedure is the same as for <a class="reference internal" href="#mdp-value-integrator-tpi"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">integrator=tpi</span></code></a>, except
that one coordinate extra is read from the trajectory, which is
used as the insertion location. The molecule to be inserted
should be centered at 0,0,0. GROMACS does not do this for you,
since for different situations a different way of centering
might be optimal. Also <a class="reference internal" href="#mdp-rtpi"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rtpi</span></code></a> sets the radius for the
sphere around this location. Neighbor searching is done only
once per frame, <a class="reference internal" href="#mdp-nstlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstlist</span></code></a> is not used. Parallel
<a class="reference internal" href="#mdp-value-integrator-tpic"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">integrator=tpic</span></code></a> gives identical results to
single-rank <a class="reference internal" href="#mdp-value-integrator-tpic"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">integrator=tpic</span></code></a>.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-integrator-mimic">
<span id="mdp-value-integrator=mimic"></span><span class="sig-name descname"><span class="pre">mimic</span></span><a class="headerlink" href="#mdp-value-integrator-mimic" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Enable MiMiC QM/MM coupling to run hybrid molecular dynamics.
Keey in mind that its required to launch CPMD compiled with MiMiC as well.
In this mode all options regarding integration (T-coupling, P-coupling,
timestep and number of steps) are ignored as CPMD will do the integration
instead. Options related to forces computation (cutoffs, PME parameters,
etc.) are working as usual. Atom selection to define QM atoms is read
from <a class="reference internal" href="#mdp-QMMM-grps"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">QMMM-grps</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-tinit">
<span class="sig-name descname"><span class="pre">tinit</span></span><a class="headerlink" href="#mdp-tinit" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [ps]
starting time for your run (only makes sense for time-based
integrators)</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-dt">
<span class="sig-name descname"><span class="pre">dt</span></span><a class="headerlink" href="#mdp-dt" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.001) [ps]
time step for integration (only makes sense for time-based
integrators)</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nsteps">
<span class="sig-name descname"><span class="pre">nsteps</span></span><a class="headerlink" href="#mdp-nsteps" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0)
maximum number of steps to integrate or minimize, -1 is no
maximum</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-init-step">
<span class="sig-name descname"><span class="pre">init-step</span></span><a class="headerlink" href="#mdp-init-step" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0)
The starting step. The time at step i in a run is
calculated as: t = <a class="reference internal" href="#mdp-tinit"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tinit</span></code></a> + <a class="reference internal" href="#mdp-dt"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">dt</span></code></a> *
(<a class="reference internal" href="#mdp-init-step"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">init-step</span></code></a> + i). The free-energy lambda is calculated
as: lambda = <a class="reference internal" href="#mdp-init-lambda"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">init-lambda</span></code></a> + <a class="reference internal" href="#mdp-delta-lambda"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">delta-lambda</span></code></a> *
(<a class="reference internal" href="#mdp-init-step"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">init-step</span></code></a> + i). Also non-equilibrium MD parameters can
depend on the step number. Thus for exact restarts or redoing
part of a run it might be necessary to set <a class="reference internal" href="#mdp-init-step"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">init-step</span></code></a> to
the step number of the restart frame. <a class="reference internal" href="../onlinehelp/gmx-convert-tpr.html#gmx-convert-tpr"><span class="std std-ref">gmx convert-tpr</span></a>
does this automatically.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-simulation-part">
<span class="sig-name descname"><span class="pre">simulation-part</span></span><a class="headerlink" href="#mdp-simulation-part" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0)
A simulation can consist of multiple parts, each of which has
a part number. This option specifies what that number will
be, which helps keep track of parts that are logically the
same simulation. This option is generally useful to set only
when coping with a crashed simulation where files were lost.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-mts">
<span class="sig-name descname"><span class="pre">mts</span></span><a class="headerlink" href="#mdp-mts" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-mts-no">
<span id="mdp-value-mts=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-mts-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Evaluate all forces at every integration step.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-mts-yes">
<span id="mdp-value-mts=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-mts-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Use a multiple timing-stepping integrator to evaluate some forces, as specified
by <a class="reference internal" href="#mdp-mts-level2-forces"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">mts-level2-forces</span></code></a> every <a class="reference internal" href="#mdp-mts-level2-factor"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">mts-level2-factor</span></code></a> integration
steps. All other forces are evaluated at every step. MTS is currently
only supported with <a class="reference internal" href="#mdp-value-integrator-md"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">integrator=md</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-mts-levels">
<span class="sig-name descname"><span class="pre">mts-levels</span></span><a class="headerlink" href="#mdp-mts-levels" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(2)
The number of levels for the multiple time-stepping scheme.
Currently only 2 is supported.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-mts-level2-forces">
<span class="sig-name descname"><span class="pre">mts-level2-forces</span></span><a class="headerlink" href="#mdp-mts-level2-forces" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(longrange-nonbonded)
A list of one or more force groups that will be evaluated only every
<a class="reference internal" href="#mdp-mts-level2-factor"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">mts-level2-factor</span></code></a> steps. Supported entries are:
<code class="docutils literal notranslate"><span class="pre">longrange-nonbonded</span></code>, <code class="docutils literal notranslate"><span class="pre">nonbonded</span></code>, <code class="docutils literal notranslate"><span class="pre">pair</span></code>, <code class="docutils literal notranslate"><span class="pre">dihedral</span></code>, <code class="docutils literal notranslate"><span class="pre">angle</span></code>,
<code class="docutils literal notranslate"><span class="pre">pull</span></code> and <code class="docutils literal notranslate"><span class="pre">awh</span></code>. With <code class="docutils literal notranslate"><span class="pre">pair</span></code> the listed pair forces (such as 1-4)
are selected. With <code class="docutils literal notranslate"><span class="pre">dihedral</span></code> all dihedrals are selected, including cmap.
All other forces, including all restraints, are evaluated and
integrated every step. When PME or Ewald is used for electrostatics
and/or LJ interactions, <code class="docutils literal notranslate"><span class="pre">longrange-nonbonded</span></code> can not be omitted here.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-mts-level2-factor">
<span class="sig-name descname"><span class="pre">mts-level2-factor</span></span><a class="headerlink" href="#mdp-mts-level2-factor" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(2) [steps]
Interval for computing the forces in level 2 of the multiple time-stepping
scheme</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-comm-mode">
<span class="sig-name descname"><span class="pre">comm-mode</span></span><a class="headerlink" href="#mdp-comm-mode" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-comm-mode-Linear">
<span id="mdp-value-comm-mode=Linear"></span><span class="sig-name descname"><span class="pre">Linear</span></span><a class="headerlink" href="#mdp-value-comm-mode-Linear" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Remove center of mass translational velocity</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-comm-mode-Angular">
<span id="mdp-value-comm-mode=Angular"></span><span class="sig-name descname"><span class="pre">Angular</span></span><a class="headerlink" href="#mdp-value-comm-mode-Angular" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Remove center of mass translational and rotational velocity</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-comm-mode-Linear-acceleration-correction">
<span id="mdp-value-comm-mode=Linear-acceleration-correction"></span><span class="sig-name descname"><span class="pre">Linear-acceleration-correction</span></span><a class="headerlink" href="#mdp-value-comm-mode-Linear-acceleration-correction" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Remove center of mass translational velocity. Correct the center of
mass position assuming linear acceleration over <a class="reference internal" href="#mdp-nstcomm"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstcomm</span></code></a> steps.
This is useful for cases where an acceleration is expected on the
center of mass which is nearly constant over <a class="reference internal" href="#mdp-nstcomm"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstcomm</span></code></a> steps.
This can occur for example when pulling on a group using an absolute
reference.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-comm-mode-None">
<span id="mdp-value-comm-mode=None"></span><span class="sig-name descname"><span class="pre">None</span></span><a class="headerlink" href="#mdp-value-comm-mode-None" title="Permalink to this definition">Â¶</a></dt>
<dd><p>No restriction on the center of mass motion</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nstcomm">
<span class="sig-name descname"><span class="pre">nstcomm</span></span><a class="headerlink" href="#mdp-nstcomm" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(100) [steps]
frequency for center of mass motion removal</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-comm-grps">
<span class="sig-name descname"><span class="pre">comm-grps</span></span><a class="headerlink" href="#mdp-comm-grps" title="Permalink to this definition">Â¶</a></dt>
<dd><p>group(s) for center of mass motion removal, default is the whole
system</p>
</dd></dl>

</section>
<section id="langevin-dynamics">
<h3>Langevin dynamics<a class="headerlink" href="#langevin-dynamics" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-bd-fric">
<span class="sig-name descname"><span class="pre">bd-fric</span></span><a class="headerlink" href="#mdp-bd-fric" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [amu ps<sup>-1</sup>]
Brownian dynamics friction coefficient. When <a class="reference internal" href="#mdp-bd-fric"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">bd-fric</span></code></a> is 0,
the friction coefficient for each particle is calculated as mass/
<a class="reference internal" href="#mdp-tau-t"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tau-t</span></code></a>.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-ld-seed">
<span class="sig-name descname"><span class="pre">ld-seed</span></span><a class="headerlink" href="#mdp-ld-seed" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(-1) [integer]
used to initialize random generator for thermal noise for
stochastic and Brownian dynamics. When <a class="reference internal" href="#mdp-ld-seed"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ld-seed</span></code></a> is set to -1,
a pseudo random seed is used. When running BD or SD on multiple
processors, each processor uses a seed equal to <a class="reference internal" href="#mdp-ld-seed"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ld-seed</span></code></a> plus
the processor number.</p>
</dd></dl>

</section>
<section id="energy-minimization">
<h3>Energy minimization<a class="headerlink" href="#energy-minimization" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-emtol">
<span class="sig-name descname"><span class="pre">emtol</span></span><a class="headerlink" href="#mdp-emtol" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(10.0) [kJ mol<sup>-1</sup> nm<sup>-1</sup>]
the minimization is converged when the maximum force is smaller
than this value</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-emstep">
<span class="sig-name descname"><span class="pre">emstep</span></span><a class="headerlink" href="#mdp-emstep" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.01) [nm]
initial step-size</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nstcgsteep">
<span class="sig-name descname"><span class="pre">nstcgsteep</span></span><a class="headerlink" href="#mdp-nstcgsteep" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1000) [steps]
frequency of performing 1 steepest descent step while doing
conjugate gradient energy minimization.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nbfgscorr">
<span class="sig-name descname"><span class="pre">nbfgscorr</span></span><a class="headerlink" href="#mdp-nbfgscorr" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(10)
Number of correction steps to use for L-BFGS minimization. A higher
number is (at least theoretically) more accurate, but slower.</p>
</dd></dl>

</section>
<section id="shell-molecular-dynamics">
<h3>Shell Molecular Dynamics<a class="headerlink" href="#shell-molecular-dynamics" title="Permalink to this headline">Â¶</a></h3>
<p>When shells or flexible constraints are present in the system the
positions of the shells and the lengths of the flexible constraints
are optimized at every time step until either the RMS force on the
shells and constraints is less than <a class="reference internal" href="#mdp-emtol"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">emtol</span></code></a>, or a maximum number
of iterations <a class="reference internal" href="#mdp-niter"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">niter</span></code></a> has been reached. Minimization is converged
when the maximum force is smaller than <a class="reference internal" href="#mdp-emtol"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">emtol</span></code></a>. For shell MD this
value should be 1.0 at most.</p>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-niter">
<span class="sig-name descname"><span class="pre">niter</span></span><a class="headerlink" href="#mdp-niter" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(20)
maximum number of iterations for optimizing the shell positions and
the flexible constraints.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-fcstep">
<span class="sig-name descname"><span class="pre">fcstep</span></span><a class="headerlink" href="#mdp-fcstep" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [ps<sup>2</sup>]
the step size for optimizing the flexible constraints. Should be
chosen as mu/(d2V/dq2) where mu is the reduced mass of two
particles in a flexible constraint and d2V/dq2 is the second
derivative of the potential in the constraint direction. Hopefully
this number does not differ too much between the flexible
constraints, as the number of iterations and thus the runtime is
very sensitive to fcstep. Try several values!</p>
</dd></dl>

</section>
<section id="test-particle-insertion">
<h3>Test particle insertion<a class="headerlink" href="#test-particle-insertion" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rtpi">
<span class="sig-name descname"><span class="pre">rtpi</span></span><a class="headerlink" href="#mdp-rtpi" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.05) [nm]
the test particle insertion radius, see integrators
<a class="reference internal" href="#mdp-value-integrator-tpi"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">integrator=tpi</span></code></a> and <a class="reference internal" href="#mdp-value-integrator-tpic"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">integrator=tpic</span></code></a></p>
</dd></dl>

</section>
<section id="output-control">
<h3>Output control<a class="headerlink" href="#output-control" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nstxout">
<span class="sig-name descname"><span class="pre">nstxout</span></span><a class="headerlink" href="#mdp-nstxout" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [steps]
number of steps that elapse between writing coordinates to the output
trajectory file (<a class="reference internal" href="../reference-manual/file-formats.html#trr"><span class="std std-ref">trr</span></a>), the last coordinates are always written
unless 0, which means coordinates are not written into the trajectory
file.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nstvout">
<span class="sig-name descname"><span class="pre">nstvout</span></span><a class="headerlink" href="#mdp-nstvout" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [steps]
number of steps that elapse between writing velocities to the output
trajectory file (<a class="reference internal" href="../reference-manual/file-formats.html#trr"><span class="std std-ref">trr</span></a>), the last velocities are always written
unless 0, which means velocities are not written into the trajectory
file.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nstfout">
<span class="sig-name descname"><span class="pre">nstfout</span></span><a class="headerlink" href="#mdp-nstfout" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [steps]
number of steps that elapse between writing forces to the output
trajectory file (<a class="reference internal" href="../reference-manual/file-formats.html#trr"><span class="std std-ref">trr</span></a>), the last forces are always written,
unless 0, which means forces are not written into the trajectory
file.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nstlog">
<span class="sig-name descname"><span class="pre">nstlog</span></span><a class="headerlink" href="#mdp-nstlog" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1000) [steps]
number of steps that elapse between writing energies to the log
file, the last energies are always written.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nstcalcenergy">
<span class="sig-name descname"><span class="pre">nstcalcenergy</span></span><a class="headerlink" href="#mdp-nstcalcenergy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(100)
number of steps that elapse between calculating the energies, 0 is
never. This option is only relevant with dynamics. This option affects the
performance in parallel simulations, because calculating energies
requires global communication between all processes which can
become a bottleneck at high parallelization.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nstenergy">
<span class="sig-name descname"><span class="pre">nstenergy</span></span><a class="headerlink" href="#mdp-nstenergy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1000) [steps]
number of steps that elapse between writing energies to energy file,
the last energies are always written, should be a multiple of
<a class="reference internal" href="#mdp-nstcalcenergy"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstcalcenergy</span></code></a>. Note that the exact sums and fluctuations
over all MD steps modulo <a class="reference internal" href="#mdp-nstcalcenergy"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstcalcenergy</span></code></a> are stored in the
energy file, so <a class="reference internal" href="../onlinehelp/gmx-energy.html#gmx-energy"><span class="std std-ref">gmx energy</span></a> can report exact energy averages
and fluctuations also when <a class="reference internal" href="#mdp-nstenergy"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstenergy</span></code></a> &gt; 1</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nstxout-compressed">
<span class="sig-name descname"><span class="pre">nstxout-compressed</span></span><a class="headerlink" href="#mdp-nstxout-compressed" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [steps]
number of steps that elapse between writing position coordinates
using lossy compression (<a class="reference internal" href="../reference-manual/file-formats.html#xtc"><span class="std std-ref">xtc</span></a> file), 0 for not writing
compressed coordinates output.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-compressed-x-precision">
<span class="sig-name descname"><span class="pre">compressed-x-precision</span></span><a class="headerlink" href="#mdp-compressed-x-precision" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1000) [real]
precision with which to write to the compressed trajectory file</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-compressed-x-grps">
<span class="sig-name descname"><span class="pre">compressed-x-grps</span></span><a class="headerlink" href="#mdp-compressed-x-grps" title="Permalink to this definition">Â¶</a></dt>
<dd><p>group(s) to write to the compressed trajectory file, by default the
whole system is written (if <a class="reference internal" href="#mdp-nstxout-compressed"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstxout-compressed</span></code></a> &gt; 0)</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-energygrps">
<span class="sig-name descname"><span class="pre">energygrps</span></span><a class="headerlink" href="#mdp-energygrps" title="Permalink to this definition">Â¶</a></dt>
<dd><p>group(s) for which to write to write short-ranged non-bonded
potential energies to the energy file (not supported on GPUs)</p>
</dd></dl>

</section>
<section id="neighbor-searching">
<h3>Neighbor searching<a class="headerlink" href="#neighbor-searching" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-cutoff-scheme">
<span class="sig-name descname"><span class="pre">cutoff-scheme</span></span><a class="headerlink" href="#mdp-cutoff-scheme" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-cutoff-scheme-Verlet">
<span id="mdp-value-cutoff-scheme=Verlet"></span><span class="sig-name descname"><span class="pre">Verlet</span></span><a class="headerlink" href="#mdp-value-cutoff-scheme-Verlet" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Generate a pair list with buffering. The buffer size is
automatically set based on <a class="reference internal" href="#mdp-verlet-buffer-tolerance"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">verlet-buffer-tolerance</span></code></a>,
unless this is set to -1, in which case <a class="reference internal" href="#mdp-rlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rlist</span></code></a> will be
used.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-cutoff-scheme-group">
<span id="mdp-value-cutoff-scheme=group"></span><span class="sig-name descname"><span class="pre">group</span></span><a class="headerlink" href="#mdp-value-cutoff-scheme-group" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Generate a pair list for groups of atoms, corresponding
to the charge groups in the topology. This option is no longer
supported.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nstlist">
<span class="sig-name descname"><span class="pre">nstlist</span></span><a class="headerlink" href="#mdp-nstlist" title="Permalink to this definition">Â¶</a></dt>
<dd><ol class="arabic simple" start="10">
<li><p>[steps]</p></li>
</ol>
<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-nstlist-0">
<span id="mdp-value-nstlist=>0"></span><span class="sig-name descname"><span class="pre">&gt;0</span></span><a class="headerlink" href="#mdp-value-nstlist-0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Frequency to update the neighbor list. When dynamics and
<a class="reference internal" href="#mdp-verlet-buffer-tolerance"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">verlet-buffer-tolerance</span></code></a> set, <a class="reference internal" href="#mdp-nstlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstlist</span></code></a> is actually
a minimum value and <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> might increase it, unless
it is set to 1. With parallel simulations and/or non-bonded
force calculation on the GPU, a value of 20 or 40 often gives
the best performance. With energy minimization this parameter
is not used as the pair list is updated when at least one atom
has moved by more than half the pair list buffer size.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-0">
<span id="mdp-value-nstlist=0"></span><span class="sig-name descname"><span class="pre">0</span></span><a class="headerlink" href="#mdp-value-0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The neighbor list is only constructed once and never
updated. This is mainly useful for vacuum simulations in which
all particles see each other. But vacuum simulations are
(temporarily) not supported.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-1">
<span id="mdp-value-nstlist=<0"></span><span class="sig-name descname"><span class="pre">&lt;0</span></span><a class="headerlink" href="#mdp-value-1" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Unused.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pbc">
<span class="sig-name descname"><span class="pre">pbc</span></span><a class="headerlink" href="#mdp-pbc" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pbc-xyz">
<span id="mdp-value-pbc=xyz"></span><span class="sig-name descname"><span class="pre">xyz</span></span><a class="headerlink" href="#mdp-value-pbc-xyz" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Use periodic boundary conditions in all directions.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pbc-no">
<span id="mdp-value-pbc=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-pbc-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Use no periodic boundary conditions, ignore the box. To simulate
without cut-offs, set all cut-offs and <a class="reference internal" href="#mdp-nstlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstlist</span></code></a> to 0. For
best performance without cut-offs on a single MPI rank, set
<a class="reference internal" href="#mdp-nstlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstlist</span></code></a> to zero and <code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">ns-type=simple</span></code>.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pbc-xy">
<span id="mdp-value-pbc=xy"></span><span class="sig-name descname"><span class="pre">xy</span></span><a class="headerlink" href="#mdp-value-pbc-xy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Use periodic boundary conditions in x and y directions
only. This works only with <code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">ns-type=grid</span></code> and can be used
in combination with <a class="reference internal" href="#walls">walls</a>. Without walls or with only one wall
the system size is infinite in the z direction. Therefore
pressure coupling or Ewald summation methods can not be
used. These disadvantages do not apply when two walls are used.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-periodic-molecules">
<span class="sig-name descname"><span class="pre">periodic-molecules</span></span><a class="headerlink" href="#mdp-periodic-molecules" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-periodic-molecules-no">
<span id="mdp-value-periodic-molecules=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-periodic-molecules-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>molecules are finite, fast molecular PBC can be used</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-periodic-molecules-yes">
<span id="mdp-value-periodic-molecules=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-periodic-molecules-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>for systems with molecules that couple to themselves through the
periodic boundary conditions, this requires a slower PBC
algorithm and molecules are not made whole in the output</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-verlet-buffer-tolerance">
<span class="sig-name descname"><span class="pre">verlet-buffer-tolerance</span></span><a class="headerlink" href="#mdp-verlet-buffer-tolerance" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.005) [kJ mol<sup>-1</sup> ps<sup>-1</sup>]</p>
<p>Used when performing a simulation with dynamics. This sets
the maximum allowed error for pair interactions per particle caused
by the Verlet buffer, which indirectly sets <a class="reference internal" href="#mdp-rlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rlist</span></code></a>. As both
<a class="reference internal" href="#mdp-nstlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstlist</span></code></a> and the Verlet buffer size are fixed (for
performance reasons), particle pairs not in the pair list can
occasionally get within the cut-off distance during
<a class="reference internal" href="#mdp-nstlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstlist</span></code></a> -1 steps. This causes very small jumps in the
energy. In a constant-temperature ensemble, these very small energy
jumps can be estimated for a given cut-off and <a class="reference internal" href="#mdp-rlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rlist</span></code></a>. The
estimate assumes a homogeneous particle distribution, hence the
errors might be slightly underestimated for multi-phase
systems. (See the <a class="reference external" href="../manual-2022.4.pdf">reference manual</a> for details). For longer
pair-list life-time (<a class="reference internal" href="#mdp-nstlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstlist</span></code></a> -1) * <a class="reference internal" href="#mdp-dt"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">dt</span></code></a> the buffer is
overestimated, because the interactions between particles are
ignored. Combined with cancellation of errors, the actual drift of
the total energy is usually one to two orders of magnitude
smaller. Note that the generated buffer size takes into account
that the GROMACS pair-list setup leads to a reduction in the
drift by a factor 10, compared to a simple particle-pair based
list. Without dynamics (energy minimization etc.), the buffer is 5%
of the cut-off. For NVE simulations the initial temperature is
used, unless this is zero, in which case a buffer of 10% is
used. For NVE simulations the tolerance usually needs to be lowered
to achieve proper energy conservation on the nanosecond time
scale. To override the automated buffer setting, use
<a class="reference internal" href="#mdp-verlet-buffer-tolerance"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">verlet-buffer-tolerance</span></code></a> =-1 and set <a class="reference internal" href="#mdp-rlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rlist</span></code></a> manually.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rlist">
<span class="sig-name descname"><span class="pre">rlist</span></span><a class="headerlink" href="#mdp-rlist" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1) [nm]
Cut-off distance for the short-range neighbor list. With dynamics,
this is by default set by the <a class="reference internal" href="#mdp-verlet-buffer-tolerance"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">verlet-buffer-tolerance</span></code></a> option
and the value of <a class="reference internal" href="#mdp-rlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rlist</span></code></a> is ignored. Without dynamics, this
is by default set to the maximum cut-off plus 5% buffer, except
for test particle insertion, where the buffer is managed exactly
and automatically. For NVE simulations, where the automated
setting is not possible, the advised procedure is to run <a class="reference internal" href="../onlinehelp/gmx-grompp.html#gmx-grompp"><span class="std std-ref">gmx grompp</span></a>
with an NVT setup with the expected temperature and copy the resulting
value of <a class="reference internal" href="#mdp-rlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rlist</span></code></a> to the NVE setup.</p>
</dd></dl>

</section>
<section id="electrostatics">
<h3>Electrostatics<a class="headerlink" href="#electrostatics" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-coulombtype">
<span class="sig-name descname"><span class="pre">coulombtype</span></span><a class="headerlink" href="#mdp-coulombtype" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-coulombtype-Cut-off">
<span id="mdp-value-coulombtype=Cut-off"></span><span class="sig-name descname"><span class="pre">Cut-off</span></span><a class="headerlink" href="#mdp-value-coulombtype-Cut-off" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Plain cut-off with pair list radius <a class="reference internal" href="#mdp-rlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rlist</span></code></a> and
Coulomb cut-off <a class="reference internal" href="#mdp-rcoulomb"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rcoulomb</span></code></a>, where <a class="reference internal" href="#mdp-rlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rlist</span></code></a> &gt;=
<a class="reference internal" href="#mdp-rcoulomb"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rcoulomb</span></code></a>.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-coulombtype-Ewald">
<span id="mdp-value-coulombtype=Ewald"></span><span class="sig-name descname"><span class="pre">Ewald</span></span><a class="headerlink" href="#mdp-value-coulombtype-Ewald" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Classical Ewald sum electrostatics. The real-space cut-off
<a class="reference internal" href="#mdp-rcoulomb"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rcoulomb</span></code></a> should be equal to <a class="reference internal" href="#mdp-rlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rlist</span></code></a>. Use <em>e.g.</em>
<a class="reference internal" href="#mdp-rlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rlist</span></code></a> =0.9, <a class="reference internal" href="#mdp-rcoulomb"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rcoulomb</span></code></a> =0.9. The highest magnitude
of wave vectors used in reciprocal space is controlled by
<a class="reference internal" href="#mdp-fourierspacing"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">fourierspacing</span></code></a>. The relative accuracy of
direct/reciprocal space is controlled by <a class="reference internal" href="#mdp-ewald-rtol"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ewald-rtol</span></code></a>.</p>
<p>NOTE: Ewald scales as O(N<sup>3/2</sup>) and is thus extremely slow for
large systems. It is included mainly for reference - in most
cases PME will perform much better.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-coulombtype-PME">
<span id="mdp-value-coulombtype=PME"></span><span class="sig-name descname"><span class="pre">PME</span></span><a class="headerlink" href="#mdp-value-coulombtype-PME" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Fast smooth Particle-Mesh Ewald (SPME) electrostatics. Direct
space is similar to the Ewald sum, while the reciprocal part is
performed with FFTs. Grid dimensions are controlled with
<a class="reference internal" href="#mdp-fourierspacing"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">fourierspacing</span></code></a> and the interpolation order with
<a class="reference internal" href="#mdp-pme-order"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pme-order</span></code></a>. With a grid spacing of 0.1 nm and cubic
interpolation the electrostatic forces have an accuracy of
2-3*10<sup>-4</sup>. Since the error from the vdw-cutoff is larger than
this you might try 0.15 nm. When running in parallel the
interpolation parallelizes better than the FFT, so try
decreasing grid dimensions while increasing interpolation.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-coulombtype-P3M-AD">
<span id="mdp-value-coulombtype=P3M-AD"></span><span class="sig-name descname"><span class="pre">P3M-AD</span></span><a class="headerlink" href="#mdp-value-coulombtype-P3M-AD" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Particle-Particle Particle-Mesh algorithm with analytical
derivative for for long range electrostatic interactions. The
method and code is identical to SPME, except that the influence
function is optimized for the grid. This gives a slight increase
in accuracy.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-coulombtype-Reaction-Field">
<span id="mdp-value-coulombtype=Reaction-Field"></span><span class="sig-name descname"><span class="pre">Reaction-Field</span></span><a class="headerlink" href="#mdp-value-coulombtype-Reaction-Field" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Reaction field electrostatics with Coulomb cut-off
<a class="reference internal" href="#mdp-rcoulomb"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rcoulomb</span></code></a>, where <a class="reference internal" href="#mdp-rlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rlist</span></code></a> &gt;= <a class="reference internal" href="#mdp-rvdw"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rvdw</span></code></a>. The
dielectric constant beyond the cut-off is
<a class="reference internal" href="#mdp-epsilon-rf"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">epsilon-rf</span></code></a>. The dielectric constant can be set to
infinity by setting <a class="reference internal" href="#mdp-epsilon-rf"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">epsilon-rf</span></code></a> =0.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-coulombtype-User">
<span id="mdp-value-coulombtype=User"></span><span class="sig-name descname"><span class="pre">User</span></span><a class="headerlink" href="#mdp-value-coulombtype-User" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Currently unsupported.
<a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> will now expect to find a file <code class="docutils literal notranslate"><span class="pre">table.xvg</span></code>
with user-defined potential functions for repulsion, dispersion
and Coulomb. When pair interactions are present, <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> also expects to find a file <code class="docutils literal notranslate"><span class="pre">tablep.xvg</span></code> for the pair
interactions. When the same interactions should be used for
non-bonded and pair interactions the user can specify the same
file name for both table files. These files should contain 7
columns: the <code class="docutils literal notranslate"><span class="pre">x</span></code> value, <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>, <code class="docutils literal notranslate"><span class="pre">-f'(x)</span></code>, <code class="docutils literal notranslate"><span class="pre">g(x)</span></code>,
<code class="docutils literal notranslate"><span class="pre">-g'(x)</span></code>, <code class="docutils literal notranslate"><span class="pre">h(x)</span></code>, <code class="docutils literal notranslate"><span class="pre">-h'(x)</span></code>, where <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> is the Coulomb
function, <code class="docutils literal notranslate"><span class="pre">g(x)</span></code> the dispersion function and <code class="docutils literal notranslate"><span class="pre">h(x)</span></code> the
repulsion function. When <a class="reference internal" href="#mdp-vdwtype"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">vdwtype</span></code></a> is not set to User the
values for <code class="docutils literal notranslate"><span class="pre">g</span></code>, <code class="docutils literal notranslate"><span class="pre">-g'</span></code>, <code class="docutils literal notranslate"><span class="pre">h</span></code> and <code class="docutils literal notranslate"><span class="pre">-h'</span></code> are ignored. For
the non-bonded interactions <code class="docutils literal notranslate"><span class="pre">x</span></code> values should run from 0 to
the largest cut-off distance + <a class="reference internal" href="#mdp-table-extension"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">table-extension</span></code></a> and
should be uniformly spaced. For the pair interactions the table
length in the file will be used. The optimal spacing, which is
used for non-user tables, is <code class="docutils literal notranslate"><span class="pre">0.002</span> <span class="pre">nm</span></code> when you run in mixed
precision or <code class="docutils literal notranslate"><span class="pre">0.0005</span> <span class="pre">nm</span></code> when you run in double precision. The
function value at <code class="docutils literal notranslate"><span class="pre">x=0</span></code> is not important. More information is
in the printed manual.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-coulombtype-PME-Switch">
<span id="mdp-value-coulombtype=PME-Switch"></span><span class="sig-name descname"><span class="pre">PME-Switch</span></span><a class="headerlink" href="#mdp-value-coulombtype-PME-Switch" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Currently unsupported.
A combination of PME and a switch function for the direct-space
part (see above). <a class="reference internal" href="#mdp-rcoulomb"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rcoulomb</span></code></a> is allowed to be smaller than
<a class="reference internal" href="#mdp-rlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rlist</span></code></a>.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-coulombtype-PME-User">
<span id="mdp-value-coulombtype=PME-User"></span><span class="sig-name descname"><span class="pre">PME-User</span></span><a class="headerlink" href="#mdp-value-coulombtype-PME-User" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Currently unsupported.
A combination of PME and user tables (see
above). <a class="reference internal" href="#mdp-rcoulomb"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rcoulomb</span></code></a> is allowed to be smaller than
<a class="reference internal" href="#mdp-rlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rlist</span></code></a>. The PME mesh contribution is subtracted from the
user table by <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a>. Because of this subtraction the
user tables should contain about 10 decimal places.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-coulombtype-PME-User-Switch">
<span id="mdp-value-coulombtype=PME-User-Switch"></span><span class="sig-name descname"><span class="pre">PME-User-Switch</span></span><a class="headerlink" href="#mdp-value-coulombtype-PME-User-Switch" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Currently unsupported.
A combination of PME-User and a switching function (see
above). The switching function is applied to final
particle-particle interaction, <em>i.e.</em> both to the user supplied
function and the PME Mesh correction part.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-coulomb-modifier">
<span class="sig-name descname"><span class="pre">coulomb-modifier</span></span><a class="headerlink" href="#mdp-coulomb-modifier" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-coulomb-modifier-Potential-shift">
<span id="mdp-value-coulomb-modifier=Potential-shift"></span><span class="sig-name descname"><span class="pre">Potential-shift</span></span><a class="headerlink" href="#mdp-value-coulomb-modifier-Potential-shift" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Shift the Coulomb potential by a constant such that it is zero
at the cut-off. This makes the potential the integral of the
force. Note that this does not affect the forces or the
sampling.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-coulomb-modifier-None">
<span id="mdp-value-coulomb-modifier=None"></span><span class="sig-name descname"><span class="pre">None</span></span><a class="headerlink" href="#mdp-value-coulomb-modifier-None" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Use an unmodified Coulomb potential. This can be useful
when comparing energies with those computed with other software.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rcoulomb-switch">
<span class="sig-name descname"><span class="pre">rcoulomb-switch</span></span><a class="headerlink" href="#mdp-rcoulomb-switch" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [nm]
where to start switching the Coulomb potential, only relevant
when force or potential switching is used</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rcoulomb">
<span class="sig-name descname"><span class="pre">rcoulomb</span></span><a class="headerlink" href="#mdp-rcoulomb" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1) [nm]
The distance for the Coulomb cut-off. Note that with PME this value
can be increased by the PME tuning in <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> along with
the PME grid spacing.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-epsilon-r">
<span class="sig-name descname"><span class="pre">epsilon-r</span></span><a class="headerlink" href="#mdp-epsilon-r" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1)
The relative dielectric constant. A value of 0 means infinity.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-epsilon-rf">
<span class="sig-name descname"><span class="pre">epsilon-rf</span></span><a class="headerlink" href="#mdp-epsilon-rf" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0)
The relative dielectric constant of the reaction field. This
is only used with reaction-field electrostatics. A value of 0
means infinity.</p>
</dd></dl>

</section>
<section id="van-der-waals">
<h3>Van der Waals<a class="headerlink" href="#van-der-waals" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-vdwtype">
<span class="sig-name descname"><span class="pre">vdwtype</span></span><a class="headerlink" href="#mdp-vdwtype" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-vdwtype-Cut-off">
<span id="mdp-value-vdwtype=Cut-off"></span><span class="sig-name descname"><span class="pre">Cut-off</span></span><a class="headerlink" href="#mdp-value-vdwtype-Cut-off" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Plain cut-off with pair list radius <a class="reference internal" href="#mdp-rlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rlist</span></code></a> and VdW
cut-off <a class="reference internal" href="#mdp-rvdw"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rvdw</span></code></a>, where <a class="reference internal" href="#mdp-rlist"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rlist</span></code></a> &gt;= <a class="reference internal" href="#mdp-rvdw"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rvdw</span></code></a>.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-vdwtype-PME">
<span id="mdp-value-vdwtype=PME"></span><span class="sig-name descname"><span class="pre">PME</span></span><a class="headerlink" href="#mdp-value-vdwtype-PME" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Fast smooth Particle-mesh Ewald (SPME) for VdW interactions. The
grid dimensions are controlled with <a class="reference internal" href="#mdp-fourierspacing"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">fourierspacing</span></code></a> in
the same way as for electrostatics, and the interpolation order
is controlled with <a class="reference internal" href="#mdp-pme-order"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pme-order</span></code></a>. The relative accuracy of
direct/reciprocal space is controlled by <a class="reference internal" href="#mdp-ewald-rtol-lj"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ewald-rtol-lj</span></code></a>,
and the specific combination rules that are to be used by the
reciprocal routine are set using <a class="reference internal" href="#mdp-lj-pme-comb-rule"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">lj-pme-comb-rule</span></code></a>.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-vdwtype-Shift">
<span id="mdp-value-vdwtype=Shift"></span><span class="sig-name descname"><span class="pre">Shift</span></span><a class="headerlink" href="#mdp-value-vdwtype-Shift" title="Permalink to this definition">Â¶</a></dt>
<dd><p>This functionality is deprecated and replaced by using
<a class="reference internal" href="#mdp-value-vdwtype-Cut-off"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">vdwtype=Cut-off</span></code></a> with <a class="reference internal" href="#mdp-value-vdw-modifier-Force-switch"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">vdw-modifier=Force-switch</span></code></a>.
The LJ (not Buckingham) potential is decreased over the whole range and
the forces decay smoothly to zero between <a class="reference internal" href="#mdp-rvdw-switch"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rvdw-switch</span></code></a> and
<a class="reference internal" href="#mdp-rvdw"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rvdw</span></code></a>.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-vdwtype-Switch">
<span id="mdp-value-vdwtype=Switch"></span><span class="sig-name descname"><span class="pre">Switch</span></span><a class="headerlink" href="#mdp-value-vdwtype-Switch" title="Permalink to this definition">Â¶</a></dt>
<dd><p>This functionality is deprecated and replaced by using
<a class="reference internal" href="#mdp-value-vdwtype-Cut-off"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">vdwtype=Cut-off</span></code></a> with <a class="reference internal" href="#mdp-value-vdw-modifier-Potential-switch"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">vdw-modifier=Potential-switch</span></code></a>.
The LJ (not Buckingham) potential is normal out to <a class="reference internal" href="#mdp-rvdw-switch"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rvdw-switch</span></code></a>, after
which it is switched off to reach zero at <a class="reference internal" href="#mdp-rvdw"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rvdw</span></code></a>. Both the
potential and force functions are continuously smooth, but be
aware that all switch functions will give rise to a bulge
(increase) in the force (since we are switching the
potential).</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-vdwtype-User">
<span id="mdp-value-vdwtype=User"></span><span class="sig-name descname"><span class="pre">User</span></span><a class="headerlink" href="#mdp-value-vdwtype-User" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Currently unsupported.
See user for <a class="reference internal" href="#mdp-coulombtype"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">coulombtype</span></code></a>. The function value at zero is
not important. When you want to use LJ correction, make sure
that <a class="reference internal" href="#mdp-rvdw"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rvdw</span></code></a> corresponds to the cut-off in the user-defined
function. When <a class="reference internal" href="#mdp-coulombtype"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">coulombtype</span></code></a> is not set to User the values
for the <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">-f'</span></code> columns are ignored.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-vdw-modifier">
<span class="sig-name descname"><span class="pre">vdw-modifier</span></span><a class="headerlink" href="#mdp-vdw-modifier" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-vdw-modifier-Potential-shift">
<span id="mdp-value-vdw-modifier=Potential-shift"></span><span class="sig-name descname"><span class="pre">Potential-shift</span></span><a class="headerlink" href="#mdp-value-vdw-modifier-Potential-shift" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Shift the Van der Waals potential by a constant such that it is
zero at the cut-off. This makes the potential the integral of
the force. Note that this does not affect the forces or the
sampling.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-vdw-modifier-None">
<span id="mdp-value-vdw-modifier=None"></span><span class="sig-name descname"><span class="pre">None</span></span><a class="headerlink" href="#mdp-value-vdw-modifier-None" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Use an unmodified Van der Waals potential. This can be useful
when comparing energies with those computed with other software.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-vdw-modifier-Force-switch">
<span id="mdp-value-vdw-modifier=Force-switch"></span><span class="sig-name descname"><span class="pre">Force-switch</span></span><a class="headerlink" href="#mdp-value-vdw-modifier-Force-switch" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Smoothly switches the forces to zero between <a class="reference internal" href="#mdp-rvdw-switch"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rvdw-switch</span></code></a>
and <a class="reference internal" href="#mdp-rvdw"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rvdw</span></code></a>. This shifts the potential shift over the whole
range and switches it to zero at the cut-off. Note that this is
more expensive to calculate than a plain cut-off and it is not
required for energy conservation, since Potential-shift
conserves energy just as well.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-vdw-modifier-Potential-switch">
<span id="mdp-value-vdw-modifier=Potential-switch"></span><span class="sig-name descname"><span class="pre">Potential-switch</span></span><a class="headerlink" href="#mdp-value-vdw-modifier-Potential-switch" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Smoothly switches the potential to zero between
<a class="reference internal" href="#mdp-rvdw-switch"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rvdw-switch</span></code></a> and <a class="reference internal" href="#mdp-rvdw"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rvdw</span></code></a>. Note that this introduces
articifically large forces in the switching region and is much
more expensive to calculate. This option should only be used if
the force field you are using requires this.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rvdw-switch">
<span class="sig-name descname"><span class="pre">rvdw-switch</span></span><a class="headerlink" href="#mdp-rvdw-switch" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [nm]
where to start switching the LJ force and possibly the potential,
only relevant when force or potential switching is used</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rvdw">
<span class="sig-name descname"><span class="pre">rvdw</span></span><a class="headerlink" href="#mdp-rvdw" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1) [nm]
distance for the LJ or Buckingham cut-off</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-DispCorr">
<span class="sig-name descname"><span class="pre">DispCorr</span></span><a class="headerlink" href="#mdp-DispCorr" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-DispCorr-no">
<span id="mdp-value-DispCorr=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-DispCorr-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>donât apply any correction</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-DispCorr-EnerPres">
<span id="mdp-value-DispCorr=EnerPres"></span><span class="sig-name descname"><span class="pre">EnerPres</span></span><a class="headerlink" href="#mdp-value-DispCorr-EnerPres" title="Permalink to this definition">Â¶</a></dt>
<dd><p>apply long range dispersion corrections for Energy and Pressure</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-DispCorr-Ener">
<span id="mdp-value-DispCorr=Ener"></span><span class="sig-name descname"><span class="pre">Ener</span></span><a class="headerlink" href="#mdp-value-DispCorr-Ener" title="Permalink to this definition">Â¶</a></dt>
<dd><p>apply long range dispersion corrections for Energy only</p>
</dd></dl>

</dd></dl>

</section>
<section id="tables">
<h3>Tables<a class="headerlink" href="#tables" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-table-extension">
<span class="sig-name descname"><span class="pre">table-extension</span></span><a class="headerlink" href="#mdp-table-extension" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1) [nm]
Extension of the non-bonded potential lookup tables beyond the
largest cut-off distance. With actual non-bonded interactions
the tables are never accessed beyond the cut-off. But a longer
table length might be needed for the 1-4 interactions, which
are always tabulated irrespective of the use of tables for
the non-bonded interactions.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-energygrp-table">
<span class="sig-name descname"><span class="pre">energygrp-table</span></span><a class="headerlink" href="#mdp-energygrp-table" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Currently unsupported.
When user tables are used for electrostatics and/or VdW, here one
can give pairs of energy groups for which separate user tables
should be used. The two energy groups will be appended to the table
file name, in order of their definition in <a class="reference internal" href="#mdp-energygrps"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">energygrps</span></code></a>,
separated by underscores. For example, if <code class="docutils literal notranslate"><span class="pre">energygrps</span> <span class="pre">=</span> <span class="pre">Na</span> <span class="pre">Cl</span>
<span class="pre">Sol</span></code> and <code class="docutils literal notranslate"><span class="pre">energygrp-table</span> <span class="pre">=</span> <span class="pre">Na</span> <span class="pre">Na</span> <span class="pre">Na</span> <span class="pre">Cl</span></code>, <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> will
read <code class="docutils literal notranslate"><span class="pre">table_Na_Na.xvg</span></code> and <code class="docutils literal notranslate"><span class="pre">table_Na_Cl.xvg</span></code> in addition to the
normal <code class="docutils literal notranslate"><span class="pre">table.xvg</span></code> which will be used for all other energy group
pairs.</p>
</dd></dl>

</section>
<section id="ewald">
<h3>Ewald<a class="headerlink" href="#ewald" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-fourierspacing">
<span class="sig-name descname"><span class="pre">fourierspacing</span></span><a class="headerlink" href="#mdp-fourierspacing" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.12) [nm]
For ordinary Ewald, the ratio of the box dimensions and the spacing
determines a lower bound for the number of wave vectors to use in
each (signed) direction. For PME and P3M, that ratio determines a
lower bound for the number of Fourier-space grid points that will
be used along that axis. In all cases, the number for each
direction can be overridden by entering a non-zero value for that
<a class="reference internal" href="#mdp-fourier-nx"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">fourier-nx</span></code></a> direction. For optimizing the relative load of
the particle-particle interactions and the mesh part of PME, it is
useful to know that the accuracy of the electrostatics remains
nearly constant when the Coulomb cut-off and the PME grid spacing
are scaled by the same factor. Note that this spacing can be scaled
up along with <a class="reference internal" href="#mdp-rcoulomb"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rcoulomb</span></code></a> by the PME tuning in <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a>.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-fourier-nx">
<span class="sig-name descname"><span class="pre">fourier-nx</span></span><a class="headerlink" href="#mdp-fourier-nx" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-fourier-ny">
<span class="sig-name descname"><span class="pre">fourier-ny</span></span><a class="headerlink" href="#mdp-fourier-ny" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-fourier-nz">
<span class="sig-name descname"><span class="pre">fourier-nz</span></span><a class="headerlink" href="#mdp-fourier-nz" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0)
Highest magnitude of wave vectors in reciprocal space when using Ewald.
Grid size when using PME or P3M. These values override
<a class="reference internal" href="#mdp-fourierspacing"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">fourierspacing</span></code></a> per direction. The best choice is powers of
2, 3, 5 and 7. Avoid large primes. Note that these grid sizes can
be reduced along with scaling up <a class="reference internal" href="#mdp-rcoulomb"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rcoulomb</span></code></a> by the PME tuning
in <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a>.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pme-order">
<span class="sig-name descname"><span class="pre">pme-order</span></span><a class="headerlink" href="#mdp-pme-order" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(4)
Interpolation order for PME. 4 equals cubic interpolation. You
might try 6/8/10 when running in parallel and simultaneously
decrease grid dimension.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-ewald-rtol">
<span class="sig-name descname"><span class="pre">ewald-rtol</span></span><a class="headerlink" href="#mdp-ewald-rtol" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(10<sup>-5</sup>)
The relative strength of the Ewald-shifted direct potential at
<a class="reference internal" href="#mdp-rcoulomb"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rcoulomb</span></code></a> is given by <a class="reference internal" href="#mdp-ewald-rtol"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ewald-rtol</span></code></a>. Decreasing this
will give a more accurate direct sum, but then you need more wave
vectors for the reciprocal sum.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-ewald-rtol-lj">
<span class="sig-name descname"><span class="pre">ewald-rtol-lj</span></span><a class="headerlink" href="#mdp-ewald-rtol-lj" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(10<sup>-3</sup>)
When doing PME for VdW-interactions, <a class="reference internal" href="#mdp-ewald-rtol-lj"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ewald-rtol-lj</span></code></a> is used
to control the relative strength of the dispersion potential at
<a class="reference internal" href="#mdp-rvdw"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rvdw</span></code></a> in the same way as <a class="reference internal" href="#mdp-ewald-rtol"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ewald-rtol</span></code></a> controls the
electrostatic potential.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-lj-pme-comb-rule">
<span class="sig-name descname"><span class="pre">lj-pme-comb-rule</span></span><a class="headerlink" href="#mdp-lj-pme-comb-rule" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(Geometric)
The combination rules used to combine VdW-parameters in the
reciprocal part of LJ-PME. Geometric rules are much faster than
Lorentz-Berthelot and usually the recommended choice, even when the
rest of the force field uses the Lorentz-Berthelot rules.</p>
<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lj-pme-comb-rule-Geometric">
<span id="mdp-value-lj-pme-comb-rule=Geometric"></span><span class="sig-name descname"><span class="pre">Geometric</span></span><a class="headerlink" href="#mdp-value-lj-pme-comb-rule-Geometric" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Apply geometric combination rules</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lj-pme-comb-rule-Lorentz-Berthelot">
<span id="mdp-value-lj-pme-comb-rule=Lorentz-Berthelot"></span><span class="sig-name descname"><span class="pre">Lorentz-Berthelot</span></span><a class="headerlink" href="#mdp-value-lj-pme-comb-rule-Lorentz-Berthelot" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Apply Lorentz-Berthelot combination rules</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-ewald-geometry">
<span class="sig-name descname"><span class="pre">ewald-geometry</span></span><a class="headerlink" href="#mdp-ewald-geometry" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-ewald-geometry-3d">
<span id="mdp-value-ewald-geometry=3d"></span><span class="sig-name descname"><span class="pre">3d</span></span><a class="headerlink" href="#mdp-value-ewald-geometry-3d" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The Ewald sum is performed in all three dimensions.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-ewald-geometry-3dc">
<span id="mdp-value-ewald-geometry=3dc"></span><span class="sig-name descname"><span class="pre">3dc</span></span><a class="headerlink" href="#mdp-value-ewald-geometry-3dc" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The reciprocal sum is still performed in 3D, but a force and
potential correction applied in the <code class="docutils literal notranslate"><span class="pre">z</span></code> dimension to produce a
pseudo-2D summation. If your system has a slab geometry in the
<code class="docutils literal notranslate"><span class="pre">x-y</span></code> plane you can try to increase the <code class="docutils literal notranslate"><span class="pre">z</span></code>-dimension of the box
(a box height of 3 times the slab height is usually ok) and use
this option.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-epsilon-surface">
<span class="sig-name descname"><span class="pre">epsilon-surface</span></span><a class="headerlink" href="#mdp-epsilon-surface" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0)
This controls the dipole correction to the Ewald summation in
3D. The default value of zero means it is turned off. Turn it on by
setting it to the value of the relative permittivity of the
imaginary surface around your infinite system. Be careful - you
shouldnât use this if you have free mobile charges in your
system. This value does not affect the slab 3DC variant of the long
range corrections.</p>
</dd></dl>

</section>
<section id="temperature-coupling">
<h3>Temperature coupling<a class="headerlink" href="#temperature-coupling" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-tcoupl">
<span class="sig-name descname"><span class="pre">tcoupl</span></span><a class="headerlink" href="#mdp-tcoupl" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-tcoupl-no">
<span id="mdp-value-tcoupl=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-tcoupl-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>No temperature coupling.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-tcoupl-berendsen">
<span id="mdp-value-tcoupl=berendsen"></span><span class="sig-name descname"><span class="pre">berendsen</span></span><a class="headerlink" href="#mdp-value-tcoupl-berendsen" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Temperature coupling with a Berendsen thermostat to a bath with
temperature <a class="reference internal" href="#mdp-ref-t"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ref-t</span></code></a>, with time constant
<a class="reference internal" href="#mdp-tau-t"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tau-t</span></code></a>. Several groups can be coupled separately, these
are specified in the <a class="reference internal" href="#mdp-tc-grps"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tc-grps</span></code></a> field separated by spaces.
This is a historical thermostat needed to be able to reproduce
previous simulations, but we strongly recommend not to use it
for new production runs. Consult the manual for details.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-tcoupl-nose-hoover">
<span id="mdp-value-tcoupl=nose-hoover"></span><span class="sig-name descname"><span class="pre">nose-hoover</span></span><a class="headerlink" href="#mdp-value-tcoupl-nose-hoover" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Temperature coupling using a Nose-Hoover extended ensemble. The
reference temperature and coupling groups are selected as above,
but in this case <a class="reference internal" href="#mdp-tau-t"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tau-t</span></code></a> controls the period of the
temperature fluctuations at equilibrium, which is slightly
different from a relaxation time. For NVT simulations the
conserved energy quantity is written to the energy and log files.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-tcoupl-andersen">
<span id="mdp-value-tcoupl=andersen"></span><span class="sig-name descname"><span class="pre">andersen</span></span><a class="headerlink" href="#mdp-value-tcoupl-andersen" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Temperature coupling by randomizing a fraction of the particle velocities
at each timestep. Reference temperature and coupling groups are
selected as above. <a class="reference internal" href="#mdp-tau-t"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tau-t</span></code></a> is the average time between
randomization of each molecule. Inhibits particle dynamics
somewhat, but little or no ergodicity issues. Currently only
implemented with velocity Verlet, and not implemented with
constraints.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-tcoupl-andersen-massive">
<span id="mdp-value-tcoupl=andersen-massive"></span><span class="sig-name descname"><span class="pre">andersen-massive</span></span><a class="headerlink" href="#mdp-value-tcoupl-andersen-massive" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Temperature coupling by randomizing velocities of all particles at
infrequent timesteps. Reference temperature and coupling groups are
selected as above. <a class="reference internal" href="#mdp-tau-t"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tau-t</span></code></a> is the time between
randomization of all molecules. Inhibits particle dynamics
somewhat, but little or no ergodicity issues. Currently only
implemented with velocity Verlet.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-tcoupl-v-rescale">
<span id="mdp-value-tcoupl=v-rescale"></span><span class="sig-name descname"><span class="pre">v-rescale</span></span><a class="headerlink" href="#mdp-value-tcoupl-v-rescale" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Temperature coupling using velocity rescaling with a stochastic
term (JCP 126, 014101). This thermostat is similar to Berendsen
coupling, with the same scaling using <a class="reference internal" href="#mdp-tau-t"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tau-t</span></code></a>, but the
stochastic term ensures that a proper canonical ensemble is
generated. The random seed is set with <a class="reference internal" href="#mdp-ld-seed"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ld-seed</span></code></a>. This
thermostat works correctly even for <a class="reference internal" href="#mdp-tau-t"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tau-t</span></code></a> =0. For NVT
simulations the conserved energy quantity is written to the
energy and log file.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nsttcouple">
<span class="sig-name descname"><span class="pre">nsttcouple</span></span><a class="headerlink" href="#mdp-nsttcouple" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(-1)
The frequency for coupling the temperature. The default value of -1
sets <a class="reference internal" href="#mdp-nsttcouple"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nsttcouple</span></code></a> equal to 10, or fewer steps if required
for accurate integration. Note that the default value is not 1
because additional computation and communication is required for
obtaining the kinetic energy. For velocity
Verlet integrators <a class="reference internal" href="#mdp-nsttcouple"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nsttcouple</span></code></a> is set to 1.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nh-chain-length">
<span class="sig-name descname"><span class="pre">nh-chain-length</span></span><a class="headerlink" href="#mdp-nh-chain-length" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(10)
The number of chained Nose-Hoover thermostats for velocity Verlet
integrators, the leap-frog <a class="reference internal" href="#mdp-value-integrator-md"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">integrator=md</span></code></a> integrator
only supports 1. Data for the NH chain variables is not printed
to the <a class="reference internal" href="../reference-manual/file-formats.html#edr"><span class="std std-ref">edr</span></a> file by default, but can be turned on with the
<a class="reference internal" href="#mdp-print-nose-hoover-chain-variables"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">print-nose-hoover-chain-variables</span></code></a> option.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-print-nose-hoover-chain-variables">
<span class="sig-name descname"><span class="pre">print-nose-hoover-chain-variables</span></span><a class="headerlink" href="#mdp-print-nose-hoover-chain-variables" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-print-nose-hoover-chain-variables-no">
<span id="mdp-value-print-nose-hoover-chain-variables=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-print-nose-hoover-chain-variables-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Do not store Nose-Hoover chain variables in the energy file.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-print-nose-hoover-chain-variables-yes">
<span id="mdp-value-print-nose-hoover-chain-variables=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-print-nose-hoover-chain-variables-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Store all positions and velocities of the Nose-Hoover chain
in the energy file.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-tc-grps">
<span class="sig-name descname"><span class="pre">tc-grps</span></span><a class="headerlink" href="#mdp-tc-grps" title="Permalink to this definition">Â¶</a></dt>
<dd><p>groups to couple to separate temperature baths</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-tau-t">
<span class="sig-name descname"><span class="pre">tau-t</span></span><a class="headerlink" href="#mdp-tau-t" title="Permalink to this definition">Â¶</a></dt>
<dd><p>[ps]
time constant for coupling (one for each group in
<a class="reference internal" href="#mdp-tc-grps"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tc-grps</span></code></a>), -1 means no temperature coupling</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-ref-t">
<span class="sig-name descname"><span class="pre">ref-t</span></span><a class="headerlink" href="#mdp-ref-t" title="Permalink to this definition">Â¶</a></dt>
<dd><p>[K]
reference temperature for coupling (one for each group in
<a class="reference internal" href="#mdp-tc-grps"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tc-grps</span></code></a>)</p>
</dd></dl>

</section>
<section id="pressure-coupling">
<h3>Pressure coupling<a class="headerlink" href="#pressure-coupling" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pcoupl">
<span class="sig-name descname"><span class="pre">pcoupl</span></span><a class="headerlink" href="#mdp-pcoupl" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pcoupl-no">
<span id="mdp-value-pcoupl=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-pcoupl-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>No pressure coupling. This means a fixed box size.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pcoupl-Berendsen">
<span id="mdp-value-pcoupl=Berendsen"></span><span class="sig-name descname"><span class="pre">Berendsen</span></span><a class="headerlink" href="#mdp-value-pcoupl-Berendsen" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Exponential relaxation pressure coupling with time constant
<a class="reference internal" href="#mdp-tau-p"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tau-p</span></code></a>. The box is scaled every <a class="reference internal" href="#mdp-nstpcouple"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstpcouple</span></code></a> steps.
This barostat does not yield a correct thermodynamic ensemble;
it is only included to be able to reproduce previous runs,
and we strongly recommend against using it for new simulations.
See the manual for details.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pcoupl-C-rescale">
<span id="mdp-value-pcoupl=C-rescale"></span><span class="sig-name descname"><span class="pre">C-rescale</span></span><a class="headerlink" href="#mdp-value-pcoupl-C-rescale" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Exponential relaxation pressure coupling with time constant
<a class="reference internal" href="#mdp-tau-p"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tau-p</span></code></a>, including a stochastic term to enforce correct
volume fluctuations.  The box is scaled every <a class="reference internal" href="#mdp-nstpcouple"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstpcouple</span></code></a>
steps. It can be used for both equilibration and production,
but presently it cannot be used for full anisotropic coupling.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pcoupl-Parrinello-Rahman">
<span id="mdp-value-pcoupl=Parrinello-Rahman"></span><span class="sig-name descname"><span class="pre">Parrinello-Rahman</span></span><a class="headerlink" href="#mdp-value-pcoupl-Parrinello-Rahman" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Extended-ensemble pressure coupling where the box vectors are
subject to an equation of motion. The equation of motion for the
atoms is coupled to this. No instantaneous scaling takes
place. As for Nose-Hoover temperature coupling the time constant
<a class="reference internal" href="#mdp-tau-p"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tau-p</span></code></a> is the period of pressure fluctuations at
equilibrium. This is probably a better method when you want to
apply pressure scaling during data collection, but beware that
you can get very large oscillations if you are starting from a
different pressure. For simulations where the exact fluctations
of the NPT ensemble are important, or if the pressure coupling
time is very short it may not be appropriate, as the previous
time step pressure is used in some steps of the GROMACS
implementation for the current time step pressure.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pcoupl-MTTK">
<span id="mdp-value-pcoupl=MTTK"></span><span class="sig-name descname"><span class="pre">MTTK</span></span><a class="headerlink" href="#mdp-value-pcoupl-MTTK" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Martyna-Tuckerman-Tobias-Klein implementation, only useable with
<a class="reference internal" href="#mdp-value-integrator-md-vv"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">integrator=md-vv</span></code></a> or <a class="reference internal" href="#mdp-value-integrator-md-vv-avek"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">integrator=md-vv-avek</span></code></a>, very similar to
Parrinello-Rahman. As for Nose-Hoover temperature coupling the
time constant <a class="reference internal" href="#mdp-tau-p"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tau-p</span></code></a> is the period of pressure
fluctuations at equilibrium. This is probably a better method
when you want to apply pressure scaling during data collection,
but beware that you can get very large oscillations if you are
starting from a different pressure. Currently (as of version
5.1), it only supports isotropic scaling, and only works without
constraints.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pcoupltype">
<span class="sig-name descname"><span class="pre">pcoupltype</span></span><a class="headerlink" href="#mdp-pcoupltype" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Specifies the kind of isotropy of the pressure coupling used. Each
kind takes one or more values for <a class="reference internal" href="#mdp-compressibility"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">compressibility</span></code></a> and
<a class="reference internal" href="#mdp-ref-p"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ref-p</span></code></a>. Only a single value is permitted for <a class="reference internal" href="#mdp-tau-p"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tau-p</span></code></a>.</p>
<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pcoupltype-isotropic">
<span id="mdp-value-pcoupltype=isotropic"></span><span class="sig-name descname"><span class="pre">isotropic</span></span><a class="headerlink" href="#mdp-value-pcoupltype-isotropic" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Isotropic pressure coupling with time constant
<a class="reference internal" href="#mdp-tau-p"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">tau-p</span></code></a>. One value each for <a class="reference internal" href="#mdp-compressibility"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">compressibility</span></code></a> and
<a class="reference internal" href="#mdp-ref-p"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ref-p</span></code></a> is required.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pcoupltype-semiisotropic">
<span id="mdp-value-pcoupltype=semiisotropic"></span><span class="sig-name descname"><span class="pre">semiisotropic</span></span><a class="headerlink" href="#mdp-value-pcoupltype-semiisotropic" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Pressure coupling which is isotropic in the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>
direction, but different in the <code class="docutils literal notranslate"><span class="pre">z</span></code> direction. This can be
useful for membrane simulations. Two values each for
<a class="reference internal" href="#mdp-compressibility"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">compressibility</span></code></a> and <a class="reference internal" href="#mdp-ref-p"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ref-p</span></code></a> are required, for
<code class="docutils literal notranslate"><span class="pre">x/y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code> directions respectively.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pcoupltype-anisotropic">
<span id="mdp-value-pcoupltype=anisotropic"></span><span class="sig-name descname"><span class="pre">anisotropic</span></span><a class="headerlink" href="#mdp-value-pcoupltype-anisotropic" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Same as before, but 6 values are needed for <code class="docutils literal notranslate"><span class="pre">xx</span></code>, <code class="docutils literal notranslate"><span class="pre">yy</span></code>, <code class="docutils literal notranslate"><span class="pre">zz</span></code>,
<code class="docutils literal notranslate"><span class="pre">xy/yx</span></code>, <code class="docutils literal notranslate"><span class="pre">xz/zx</span></code> and <code class="docutils literal notranslate"><span class="pre">yz/zy</span></code> components,
respectively. When the off-diagonal compressibilities are set to
zero, a rectangular box will stay rectangular. Beware that
anisotropic scaling can lead to extreme deformation of the
simulation box.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pcoupltype-surface-tension">
<span id="mdp-value-pcoupltype=surface-tension"></span><span class="sig-name descname"><span class="pre">surface-tension</span></span><a class="headerlink" href="#mdp-value-pcoupltype-surface-tension" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Surface tension coupling for surfaces parallel to the
xy-plane. Uses normal pressure coupling for the <code class="docutils literal notranslate"><span class="pre">z</span></code>-direction,
while the surface tension is coupled to the <code class="docutils literal notranslate"><span class="pre">x/y</span></code> dimensions of
the box. The first <a class="reference internal" href="#mdp-ref-p"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ref-p</span></code></a> value is the reference surface
tension times the number of surfaces <code class="docutils literal notranslate"><span class="pre">bar</span> <span class="pre">nm</span></code>, the second
value is the reference <code class="docutils literal notranslate"><span class="pre">z</span></code>-pressure <code class="docutils literal notranslate"><span class="pre">bar</span></code>. The two
<a class="reference internal" href="#mdp-compressibility"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">compressibility</span></code></a> values are the compressibility in the
<code class="docutils literal notranslate"><span class="pre">x/y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code> direction respectively. The value for the
<code class="docutils literal notranslate"><span class="pre">z</span></code>-compressibility should be reasonably accurate since it
influences the convergence of the surface-tension, it can also
be set to zero to have a box with constant height.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nstpcouple">
<span class="sig-name descname"><span class="pre">nstpcouple</span></span><a class="headerlink" href="#mdp-nstpcouple" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(-1)
The frequency for coupling the pressure. The default value of -1
sets <a class="reference internal" href="#mdp-nstpcouple"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstpcouple</span></code></a> equal to 10, or fewer steps if required
for accurate integration. Note that the default value is not 1
because additional computation and communication is required for
obtaining the virial. For velocity
Verlet integrators <a class="reference internal" href="#mdp-nstpcouple"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstpcouple</span></code></a> is set to 1.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-tau-p">
<span class="sig-name descname"><span class="pre">tau-p</span></span><a class="headerlink" href="#mdp-tau-p" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1) [ps]
The time constant for pressure coupling (one value for all
directions).</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-compressibility">
<span class="sig-name descname"><span class="pre">compressibility</span></span><a class="headerlink" href="#mdp-compressibility" title="Permalink to this definition">Â¶</a></dt>
<dd><p>[bar<sup>-1</sup>]
The compressibility (NOTE: this is now really in bar<sup>-1</sup>) For water at 1
atm and 300 K the compressibility is 4.5e-5 bar<sup>-1</sup>. The number of
required values is implied by <a class="reference internal" href="#mdp-pcoupltype"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pcoupltype</span></code></a>.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-ref-p">
<span class="sig-name descname"><span class="pre">ref-p</span></span><a class="headerlink" href="#mdp-ref-p" title="Permalink to this definition">Â¶</a></dt>
<dd><p>[bar]
The reference pressure for coupling. The number of required values
is implied by <a class="reference internal" href="#mdp-pcoupltype"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pcoupltype</span></code></a>.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-refcoord-scaling">
<span class="sig-name descname"><span class="pre">refcoord-scaling</span></span><a class="headerlink" href="#mdp-refcoord-scaling" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-refcoord-scaling-no">
<span id="mdp-value-refcoord-scaling=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-refcoord-scaling-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The reference coordinates for position restraints are not
modified. Note that with this option the virial and pressure
might be ill defined, see <a class="reference internal" href="../reference-manual/functions/restraints.html#reference-manual-position-restraints"><span class="std std-ref">here</span></a>
for more details.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-refcoord-scaling-all">
<span id="mdp-value-refcoord-scaling=all"></span><span class="sig-name descname"><span class="pre">all</span></span><a class="headerlink" href="#mdp-value-refcoord-scaling-all" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The reference coordinates are scaled with the scaling matrix of
the pressure coupling.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-refcoord-scaling-com">
<span id="mdp-value-refcoord-scaling=com"></span><span class="sig-name descname"><span class="pre">com</span></span><a class="headerlink" href="#mdp-value-refcoord-scaling-com" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Scale the center of mass of the reference coordinates with the
scaling matrix of the pressure coupling. The vectors of each
reference coordinate to the center of mass are not scaled. Only
one COM is used, even when there are multiple molecules with
position restraints. For calculating the COM of the reference
coordinates in the starting configuration, periodic boundary
conditions are not taken into account. Note that with this option
the virial and pressure might be ill defined, see
<a class="reference internal" href="../reference-manual/functions/restraints.html#reference-manual-position-restraints"><span class="std std-ref">here</span></a> for more details.</p>
</dd></dl>

</dd></dl>

</section>
<section id="simulated-annealing">
<h3>Simulated annealing<a class="headerlink" href="#simulated-annealing" title="Permalink to this headline">Â¶</a></h3>
<p>Simulated annealing is controlled separately for each temperature
group in GROMACS. The reference temperature is a piecewise linear
function, but you can use an arbitrary number of points for each
group, and choose either a single sequence or a periodic behaviour for
each group. The actual annealing is performed by dynamically changing
the reference temperature used in the thermostat algorithm selected,
so remember that the system will usually not instantaneously reach the
reference temperature!</p>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-annealing">
<span class="sig-name descname"><span class="pre">annealing</span></span><a class="headerlink" href="#mdp-annealing" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Type of annealing for each temperature group</p>
<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-annealing-no">
<span id="mdp-value-annealing=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-annealing-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>No simulated annealing - just couple to reference temperature value.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-annealing-single">
<span id="mdp-value-annealing=single"></span><span class="sig-name descname"><span class="pre">single</span></span><a class="headerlink" href="#mdp-value-annealing-single" title="Permalink to this definition">Â¶</a></dt>
<dd><p>A single sequence of annealing points. If your simulation is
longer than the time of the last point, the temperature will be
coupled to this constant value after the annealing sequence has
reached the last time point.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-annealing-periodic">
<span id="mdp-value-annealing=periodic"></span><span class="sig-name descname"><span class="pre">periodic</span></span><a class="headerlink" href="#mdp-value-annealing-periodic" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The annealing will start over at the first reference point once
the last reference time is reached. This is repeated until the
simulation ends.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-annealing-npoints">
<span class="sig-name descname"><span class="pre">annealing-npoints</span></span><a class="headerlink" href="#mdp-annealing-npoints" title="Permalink to this definition">Â¶</a></dt>
<dd><p>A list with the number of annealing reference/control points used
for each temperature group. Use 0 for groups that are not
annealed. The number of entries should equal the number of
temperature groups.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-annealing-time">
<span class="sig-name descname"><span class="pre">annealing-time</span></span><a class="headerlink" href="#mdp-annealing-time" title="Permalink to this definition">Â¶</a></dt>
<dd><p>List of times at the annealing reference/control points for each
group. If you are using periodic annealing, the times will be used
modulo the last value, <em>i.e.</em> if the values are 0, 5, 10, and 15,
the coupling will restart at the 0ps value after 15ps, 30ps, 45ps,
etc. The number of entries should equal the sum of the numbers
given in <a class="reference internal" href="#mdp-annealing-npoints"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">annealing-npoints</span></code></a>.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-annealing-temp">
<span class="sig-name descname"><span class="pre">annealing-temp</span></span><a class="headerlink" href="#mdp-annealing-temp" title="Permalink to this definition">Â¶</a></dt>
<dd><p>List of temperatures at the annealing reference/control points for
each group. The number of entries should equal the sum of the
numbers given in <a class="reference internal" href="#mdp-annealing-npoints"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">annealing-npoints</span></code></a>.</p>
</dd></dl>

<p>Confused? OK, letâs use an example. Assume you have two temperature
groups, set the group selections to <code class="docutils literal notranslate"><span class="pre">annealing</span> <span class="pre">=</span> <span class="pre">single</span> <span class="pre">periodic</span></code>,
the number of points of each group to <code class="docutils literal notranslate"><span class="pre">annealing-npoints</span> <span class="pre">=</span> <span class="pre">3</span> <span class="pre">4</span></code>, the
times to <code class="docutils literal notranslate"><span class="pre">annealing-time</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">3</span> <span class="pre">6</span> <span class="pre">0</span> <span class="pre">2</span> <span class="pre">4</span> <span class="pre">6</span></code> and finally temperatures
to <code class="docutils literal notranslate"><span class="pre">annealing-temp</span> <span class="pre">=</span> <span class="pre">298</span> <span class="pre">280</span> <span class="pre">270</span> <span class="pre">298</span> <span class="pre">320</span> <span class="pre">320</span> <span class="pre">298</span></code>. The first group
will be coupled to 298K at 0ps, but the reference temperature will
drop linearly to reach 280K at 3ps, and then linearly between 280K and
270K from 3ps to 6ps. After this is stays constant, at 270K. The
second group is coupled to 298K at 0ps, it increases linearly to 320K
at 2ps, where it stays constant until 4ps. Between 4ps and 6ps it
decreases to 298K, and then it starts over with the same pattern
again, <em>i.e.</em> rising linearly from 298K to 320K between 6ps and
8ps. Check the summary printed by <a class="reference internal" href="../onlinehelp/gmx-grompp.html#gmx-grompp"><span class="std std-ref">gmx grompp</span></a> if you are unsure!</p>
</section>
<section id="velocity-generation">
<h3>Velocity generation<a class="headerlink" href="#velocity-generation" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-gen-vel">
<span class="sig-name descname"><span class="pre">gen-vel</span></span><a class="headerlink" href="#mdp-gen-vel" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-gen-vel-no">
<span id="mdp-value-gen-vel=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-gen-vel-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Do not generate velocities. The velocities are set to zero
when there are no velocities in the input structure file.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-gen-vel-yes">
<span id="mdp-value-gen-vel=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-gen-vel-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Generate velocities in <a class="reference internal" href="../onlinehelp/gmx-grompp.html#gmx-grompp"><span class="std std-ref">gmx grompp</span></a> according to a
Maxwell distribution at temperature <a class="reference internal" href="#mdp-gen-temp"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">gen-temp</span></code></a>, with
random seed <a class="reference internal" href="#mdp-gen-seed"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">gen-seed</span></code></a>. This is only meaningful with
<a class="reference internal" href="#mdp-value-integrator-md"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">integrator=md</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-gen-temp">
<span class="sig-name descname"><span class="pre">gen-temp</span></span><a class="headerlink" href="#mdp-gen-temp" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(300) [K]
temperature for Maxwell distribution</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-gen-seed">
<span class="sig-name descname"><span class="pre">gen-seed</span></span><a class="headerlink" href="#mdp-gen-seed" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(-1) [integer]
used to initialize random generator for random velocities,
when <a class="reference internal" href="#mdp-gen-seed"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">gen-seed</span></code></a> is set to -1, a pseudo random seed is
used.</p>
</dd></dl>

</section>
<section id="bonds">
<h3>Bonds<a class="headerlink" href="#bonds" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-constraints">
<span class="sig-name descname"><span class="pre">constraints</span></span><a class="headerlink" href="#mdp-constraints" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Controls which bonds in the topology will be converted to rigid
holonomic constraints. Note that typical rigid water models do not
have bonds, but rather a specialized <code class="docutils literal notranslate"><span class="pre">[settles]</span></code> directive, so
are not affected by this keyword.</p>
<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-constraints-none">
<span id="mdp-value-constraints=none"></span><span class="sig-name descname"><span class="pre">none</span></span><a class="headerlink" href="#mdp-value-constraints-none" title="Permalink to this definition">Â¶</a></dt>
<dd><p>No bonds converted to constraints.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-constraints-h-bonds">
<span id="mdp-value-constraints=h-bonds"></span><span class="sig-name descname"><span class="pre">h-bonds</span></span><a class="headerlink" href="#mdp-value-constraints-h-bonds" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Convert the bonds with H-atoms to constraints.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-constraints-all-bonds">
<span id="mdp-value-constraints=all-bonds"></span><span class="sig-name descname"><span class="pre">all-bonds</span></span><a class="headerlink" href="#mdp-value-constraints-all-bonds" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Convert all bonds to constraints.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-constraints-h-angles">
<span id="mdp-value-constraints=h-angles"></span><span class="sig-name descname"><span class="pre">h-angles</span></span><a class="headerlink" href="#mdp-value-constraints-h-angles" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Convert all bonds to constraints and convert the angles that
involve H-atoms to bond-constraints.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-constraints-all-angles">
<span id="mdp-value-constraints=all-angles"></span><span class="sig-name descname"><span class="pre">all-angles</span></span><a class="headerlink" href="#mdp-value-constraints-all-angles" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Convert all bonds to constraints and all angles to bond-constraints.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-constraint-algorithm">
<span class="sig-name descname"><span class="pre">constraint-algorithm</span></span><a class="headerlink" href="#mdp-constraint-algorithm" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Chooses which solver satisfies any non-SETTLE holonomic
constraints.</p>
<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-constraint-algorithm-LINCS">
<span id="mdp-value-constraint-algorithm=LINCS"></span><span class="sig-name descname"><span class="pre">LINCS</span></span><a class="headerlink" href="#mdp-value-constraint-algorithm-LINCS" title="Permalink to this definition">Â¶</a></dt>
<dd><p>LINear Constraint Solver. With domain decomposition the parallel
version P-LINCS is used. The accuracy in set with
<a class="reference internal" href="#mdp-lincs-order"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">lincs-order</span></code></a>, which sets the number of matrices in the
expansion for the matrix inversion. After the matrix inversion
correction the algorithm does an iterative correction to
compensate for lengthening due to rotation. The number of such
iterations can be controlled with <a class="reference internal" href="#mdp-lincs-iter"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">lincs-iter</span></code></a>. The root
mean square relative constraint deviation is printed to the log
file every <a class="reference internal" href="#mdp-nstlog"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstlog</span></code></a> steps. If a bond rotates more than
<a class="reference internal" href="#mdp-lincs-warnangle"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">lincs-warnangle</span></code></a> in one step, a warning will be printed
both to the log file and to <code class="docutils literal notranslate"><span class="pre">stderr</span></code>. LINCS should not be used
with coupled angle constraints.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-constraint-algorithm-SHAKE">
<span id="mdp-value-constraint-algorithm=SHAKE"></span><span class="sig-name descname"><span class="pre">SHAKE</span></span><a class="headerlink" href="#mdp-value-constraint-algorithm-SHAKE" title="Permalink to this definition">Â¶</a></dt>
<dd><p>SHAKE is slightly slower and less stable than LINCS, but does
work with angle constraints. The relative tolerance is set with
<a class="reference internal" href="#mdp-shake-tol"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">shake-tol</span></code></a>, 0.0001 is a good value for ânormalâ MD. SHAKE
does not support constraints between atoms on different
decomposition domains, so it can only be used with domain
decomposition when so-called update-groups are used, which is
usally the case when only bonds involving hydrogens are
constrained. SHAKE can not be used with energy minimization.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-continuation">
<span class="sig-name descname"><span class="pre">continuation</span></span><a class="headerlink" href="#mdp-continuation" title="Permalink to this definition">Â¶</a></dt>
<dd><p>This option was formerly known as <code class="docutils literal notranslate"><span class="pre">unconstrained-start</span></code>.</p>
<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-continuation-no">
<span id="mdp-value-continuation=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-continuation-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>apply constraints to the start configuration and reset shells</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-continuation-yes">
<span id="mdp-value-continuation=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-continuation-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>do not apply constraints to the start configuration and do not
reset shells, useful for exact coninuation and reruns</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-shake-tol">
<span class="sig-name descname"><span class="pre">shake-tol</span></span><a class="headerlink" href="#mdp-shake-tol" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.0001)
relative tolerance for SHAKE</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-lincs-order">
<span class="sig-name descname"><span class="pre">lincs-order</span></span><a class="headerlink" href="#mdp-lincs-order" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(4)
Highest order in the expansion of the constraint coupling
matrix. When constraints form triangles, an additional expansion of
the same order is applied on top of the normal expansion only for
the couplings within such triangles. For ânormalâ MD simulations an
order of 4 usually suffices, 6 is needed for large time-steps with
virtual sites or BD. For accurate energy minimization in double
precision an order of 8 or more might be required. Note that in
single precision an order higher than 6 will often lead to worse
accuracy due to amplification of rounding errors.
With domain decomposition, the cell size
is limited by the distance spanned by <a class="reference internal" href="#mdp-lincs-order"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">lincs-order</span></code></a> +1
constraints. When one wants to scale further than this limit, one
can decrease <a class="reference internal" href="#mdp-lincs-order"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">lincs-order</span></code></a> and increase <a class="reference internal" href="#mdp-lincs-iter"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">lincs-iter</span></code></a>,
since the accuracy does not deteriorate when (1+ <a class="reference internal" href="#mdp-lincs-iter"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">lincs-iter</span></code></a>
)* <a class="reference internal" href="#mdp-lincs-order"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">lincs-order</span></code></a> remains constant.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-lincs-iter">
<span class="sig-name descname"><span class="pre">lincs-iter</span></span><a class="headerlink" href="#mdp-lincs-iter" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1)
Number of iterations to correct for rotational lengthening in
LINCS. For normal runs a single step is sufficient, but for NVE
runs where you want to conserve energy accurately or for accurate
energy minimization in double precision you might want to increase
it to 2. Note that in single precision using more than 1 iteration
will often lead to worse accuracy due to amplification of rounding
errors.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-lincs-warnangle">
<span class="sig-name descname"><span class="pre">lincs-warnangle</span></span><a class="headerlink" href="#mdp-lincs-warnangle" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(30) [deg]
maximum angle that a bond can rotate before LINCS will complain</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-morse">
<span class="sig-name descname"><span class="pre">morse</span></span><a class="headerlink" href="#mdp-morse" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-morse-no">
<span id="mdp-value-morse=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-morse-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>bonds are represented by a harmonic potential</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-morse-yes">
<span id="mdp-value-morse=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-morse-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>bonds are represented by a Morse potential</p>
</dd></dl>

</dd></dl>

</section>
<section id="energy-group-exclusions">
<h3>Energy group exclusions<a class="headerlink" href="#energy-group-exclusions" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-energygrp-excl">
<span class="sig-name descname"><span class="pre">energygrp-excl</span></span><a class="headerlink" href="#mdp-energygrp-excl" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Pairs of energy groups for which all non-bonded interactions are
excluded. An example: if you have two energy groups <code class="docutils literal notranslate"><span class="pre">Protein</span></code> and
<code class="docutils literal notranslate"><span class="pre">SOL</span></code>, specifying <code class="docutils literal notranslate"><span class="pre">energygrp-excl</span> <span class="pre">=</span> <span class="pre">Protein</span> <span class="pre">Protein</span> <span class="pre">SOL</span> <span class="pre">SOL</span></code>
would give only the non-bonded interactions between the protein and
the solvent. This is especially useful for speeding up energy
calculations with <code class="docutils literal notranslate"><span class="pre">mdrun</span> <span class="pre">-rerun</span></code> and for excluding interactions
within frozen groups.</p>
</dd></dl>

</section>
<section id="walls">
<h3>Walls<a class="headerlink" href="#walls" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nwall">
<span class="sig-name descname"><span class="pre">nwall</span></span><a class="headerlink" href="#mdp-nwall" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0)
When set to 1 there is a wall at <code class="docutils literal notranslate"><span class="pre">z=0</span></code>, when set to 2 there is
also a wall at <code class="docutils literal notranslate"><span class="pre">z=z-box</span></code>. Walls can only be used with <a class="reference internal" href="#mdp-pbc"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pbc</span></code></a>
<code class="docutils literal notranslate"><span class="pre">=xy</span></code>. When set to 2, pressure coupling and Ewald summation can be
used (it is usually best to use semiisotropic pressure coupling
with the <code class="docutils literal notranslate"><span class="pre">x/y</span></code> compressibility set to 0, as otherwise the surface
area will change). Walls interact wit the rest of the system
through an optional <a class="reference internal" href="#mdp-wall-atomtype"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">wall-atomtype</span></code></a>. Energy groups <code class="docutils literal notranslate"><span class="pre">wall0</span></code>
and <code class="docutils literal notranslate"><span class="pre">wall1</span></code> (for <a class="reference internal" href="#mdp-nwall"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nwall</span></code></a> =2) are added automatically to
monitor the interaction of energy groups with each wall. The center
of mass motion removal will be turned off in the <code class="docutils literal notranslate"><span class="pre">z</span></code>-direction.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-wall-atomtype">
<span class="sig-name descname"><span class="pre">wall-atomtype</span></span><a class="headerlink" href="#mdp-wall-atomtype" title="Permalink to this definition">Â¶</a></dt>
<dd><p>the atom type name in the force field for each wall. By (for
example) defining a special wall atom type in the topology with its
own combination rules, this allows for independent tuning of the
interaction of each atomtype with the walls.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-wall-type">
<span class="sig-name descname"><span class="pre">wall-type</span></span><a class="headerlink" href="#mdp-wall-type" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-wall-type-9-3">
<span id="mdp-value-wall-type=9-3"></span><span class="sig-name descname"><span class="pre">9-3</span></span><a class="headerlink" href="#mdp-value-wall-type-9-3" title="Permalink to this definition">Â¶</a></dt>
<dd><p>LJ integrated over the volume behind the wall: 9-3 potential</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-wall-type-10-4">
<span id="mdp-value-wall-type=10-4"></span><span class="sig-name descname"><span class="pre">10-4</span></span><a class="headerlink" href="#mdp-value-wall-type-10-4" title="Permalink to this definition">Â¶</a></dt>
<dd><p>LJ integrated over the wall surface: 10-4 potential</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-wall-type-12-6">
<span id="mdp-value-wall-type=12-6"></span><span class="sig-name descname"><span class="pre">12-6</span></span><a class="headerlink" href="#mdp-value-wall-type-12-6" title="Permalink to this definition">Â¶</a></dt>
<dd><p>direct LJ potential with the <code class="docutils literal notranslate"><span class="pre">z</span></code> distance from the wall</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-table">
<span class="sig-name descname"><span class="pre">table</span></span><a class="headerlink" href="#mdp-table" title="Permalink to this definition">Â¶</a></dt>
<dd><p>user defined potentials indexed with the <code class="docutils literal notranslate"><span class="pre">z</span></code> distance from the
wall, the tables are read analogously to the
<a class="reference internal" href="#mdp-energygrp-table"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">energygrp-table</span></code></a> option, where the first name is for a
ânormalâ energy group and the second name is <code class="docutils literal notranslate"><span class="pre">wall0</span></code> or
<code class="docutils literal notranslate"><span class="pre">wall1</span></code>, only the dispersion and repulsion columns are used</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-wall-r-linpot">
<span class="sig-name descname"><span class="pre">wall-r-linpot</span></span><a class="headerlink" href="#mdp-wall-r-linpot" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(-1) [nm]
Below this distance from the wall the potential is continued
linearly and thus the force is constant. Setting this option to a
postive value is especially useful for equilibration when some
atoms are beyond a wall. When the value is &lt;=0 (&lt;0 for
<a class="reference internal" href="#mdp-wall-type"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">wall-type</span></code></a> =table), a fatal error is generated when atoms
are beyond a wall.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-wall-density">
<span class="sig-name descname"><span class="pre">wall-density</span></span><a class="headerlink" href="#mdp-wall-density" title="Permalink to this definition">Â¶</a></dt>
<dd><p>[nm<sup>-3</sup>] / [nm<sup>-2</sup>]
the number density of the atoms for each wall for wall types 9-3
and 10-4</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-wall-ewald-zfac">
<span class="sig-name descname"><span class="pre">wall-ewald-zfac</span></span><a class="headerlink" href="#mdp-wall-ewald-zfac" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(3)
The scaling factor for the third box vector for Ewald summation
only, the minimum is 2. Ewald summation can only be used with
<a class="reference internal" href="#mdp-nwall"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nwall</span></code></a> =2, where one should use <a class="reference internal" href="#mdp-ewald-geometry"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ewald-geometry</span></code></a>
<code class="docutils literal notranslate"><span class="pre">=3dc</span></code>. The empty layer in the box serves to decrease the
unphysical Coulomb interaction between periodic images.</p>
</dd></dl>

</section>
<section id="com-pulling">
<h3>COM pulling<a class="headerlink" href="#com-pulling" title="Permalink to this headline">Â¶</a></h3>
<p>Sets whether pulling on collective variables is active.
Note that where pulling coordinates are applicable, there can be more
than one (set with <a class="reference internal" href="#mdp-pull-ncoords"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-ncoords</span></code></a>) and multiple related <a class="reference internal" href="../reference-manual/file-formats.html#mdp"><span class="std std-ref">mdp</span></a>
variables will exist accordingly. Documentation references to things
like <a class="reference internal" href="#mdp-pull-coord1-vec"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-vec</span></code></a> should be understood to apply to to the
applicable pulling coordinate, eg. the second pull coordinate is described by
pull-coord2-vec, pull-coord2-k, and so on.</p>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull">
<span class="sig-name descname"><span class="pre">pull</span></span><a class="headerlink" href="#mdp-pull" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-no">
<span id="mdp-value-pull=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-pull-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>No center of mass pulling. All the following pull options will
be ignored (and if present in the <a class="reference internal" href="../reference-manual/file-formats.html#mdp"><span class="std std-ref">mdp</span></a> file, they unfortunately
generate warnings)</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-yes">
<span id="mdp-value-pull=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-pull-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Center of mass pulling will be applied on 1 or more groups using
1 or more pull coordinates.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-cylinder-r">
<span class="sig-name descname"><span class="pre">pull-cylinder-r</span></span><a class="headerlink" href="#mdp-pull-cylinder-r" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1.5) [nm]
the radius of the cylinder for <a class="reference internal" href="#mdp-value-pull-coord1-geometry-cylinder"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">pull-coord1-geometry=cylinder</span></code></a></p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-constr-tol">
<span class="sig-name descname"><span class="pre">pull-constr-tol</span></span><a class="headerlink" href="#mdp-pull-constr-tol" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(10<sup>-6</sup>)
the relative constraint tolerance for constraint pulling</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-print-com">
<span class="sig-name descname"><span class="pre">pull-print-com</span></span><a class="headerlink" href="#mdp-pull-print-com" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-print-com-no">
<span id="mdp-value-pull-print-com=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-pull-print-com-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>do not print the COM for any group</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-print-com-yes">
<span id="mdp-value-pull-print-com=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-pull-print-com-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>print the COM of all groups for all pull coordinates</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-print-ref-value">
<span class="sig-name descname"><span class="pre">pull-print-ref-value</span></span><a class="headerlink" href="#mdp-pull-print-ref-value" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-print-ref-value-no">
<span id="mdp-value-pull-print-ref-value=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-pull-print-ref-value-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>do not print the reference value for each pull coordinate</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-print-ref-value-yes">
<span id="mdp-value-pull-print-ref-value=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-pull-print-ref-value-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>print the reference value for each pull coordinate</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-print-components">
<span class="sig-name descname"><span class="pre">pull-print-components</span></span><a class="headerlink" href="#mdp-pull-print-components" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-print-components-no">
<span id="mdp-value-pull-print-components=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-pull-print-components-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>only print the distance for each pull coordinate</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-print-components-yes">
<span id="mdp-value-pull-print-components=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-pull-print-components-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>print the distance and Cartesian components selected in
<a class="reference internal" href="#mdp-pull-coord1-dim"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-dim</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-nstxout">
<span class="sig-name descname"><span class="pre">pull-nstxout</span></span><a class="headerlink" href="#mdp-pull-nstxout" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(50)
frequency for writing out the COMs of all the pull group (0 is
never)</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-nstfout">
<span class="sig-name descname"><span class="pre">pull-nstfout</span></span><a class="headerlink" href="#mdp-pull-nstfout" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(50)
frequency for writing out the force of all the pulled group
(0 is never)</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-pbc-ref-prev-step-com">
<span class="sig-name descname"><span class="pre">pull-pbc-ref-prev-step-com</span></span><a class="headerlink" href="#mdp-pull-pbc-ref-prev-step-com" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-pbc-ref-prev-step-com-no">
<span id="mdp-value-pull-pbc-ref-prev-step-com=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-pull-pbc-ref-prev-step-com-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Use the reference atom (<a class="reference internal" href="#mdp-pull-group1-pbcatom"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-group1-pbcatom</span></code></a>) for the
treatment of periodic boundary conditions.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-pbc-ref-prev-step-com-yes">
<span id="mdp-value-pull-pbc-ref-prev-step-com=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-pull-pbc-ref-prev-step-com-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Use the COM of the previous step as reference for the treatment
of periodic boundary conditions. The reference is initialized
using the reference atom (<a class="reference internal" href="#mdp-pull-group1-pbcatom"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-group1-pbcatom</span></code></a>), which should
be located centrally in the group. Using the COM from the
previous step can be useful if one or more pull groups are large.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-xout-average">
<span class="sig-name descname"><span class="pre">pull-xout-average</span></span><a class="headerlink" href="#mdp-pull-xout-average" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-xout-average-no">
<span id="mdp-value-pull-xout-average=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-pull-xout-average-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Write the instantaneous coordinates for all the pulled groups.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-xout-average-yes">
<span id="mdp-value-pull-xout-average=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-pull-xout-average-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Write the average coordinates (since last output) for all the
pulled groups. N.b., some analysis tools might expect instantaneous
pull output.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-fout-average">
<span class="sig-name descname"><span class="pre">pull-fout-average</span></span><a class="headerlink" href="#mdp-pull-fout-average" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-fout-average-no">
<span id="mdp-value-pull-fout-average=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-pull-fout-average-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Write the instantaneous force for all the pulled groups.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-fout-average-yes">
<span id="mdp-value-pull-fout-average=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-pull-fout-average-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Write the average force (since last output) for all the
pulled groups. N.b., some analysis tools might expect instantaneous
pull output.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-ngroups">
<span class="sig-name descname"><span class="pre">pull-ngroups</span></span><a class="headerlink" href="#mdp-pull-ngroups" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1)
The number of pull groups, not including the absolute reference
group, when used. Pull groups can be reused in multiple pull
coordinates. Below only the pull options for group 1 are given,
further groups simply increase the group index number.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-ncoords">
<span class="sig-name descname"><span class="pre">pull-ncoords</span></span><a class="headerlink" href="#mdp-pull-ncoords" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1)
The number of pull coordinates. Below only the pull options for
coordinate 1 are given, further coordinates simply increase the
coordinate index number.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-group1-name">
<span class="sig-name descname"><span class="pre">pull-group1-name</span></span><a class="headerlink" href="#mdp-pull-group1-name" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The name of the pull group, is looked up in the index file or in
the default groups to obtain the atoms involved.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-group1-weights">
<span class="sig-name descname"><span class="pre">pull-group1-weights</span></span><a class="headerlink" href="#mdp-pull-group1-weights" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Optional relative weights which are multiplied with the masses of
the atoms to give the total weight for the COM. The number should
be 0, meaning all 1, or the number of atoms in the pull group.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-group1-pbcatom">
<span class="sig-name descname"><span class="pre">pull-group1-pbcatom</span></span><a class="headerlink" href="#mdp-pull-group1-pbcatom" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0)
The reference atom for the treatment of periodic boundary
conditions inside the group (this has no effect on the treatment of
the pbc between groups). This option is only important when the
diameter of the pull group is larger than half the shortest box
vector. For determining the COM, all atoms in the group are put at
their periodic image which is closest to
<a class="reference internal" href="#mdp-pull-group1-pbcatom"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-group1-pbcatom</span></code></a>. A value of 0 means that the middle
atom (number wise) is used, which is only safe for small groups.
<a class="reference internal" href="../onlinehelp/gmx-grompp.html#gmx-grompp"><span class="std std-ref">gmx grompp</span></a> checks that the maximum distance from the reference
atom (specifically chosen, or not) to the other atoms in the group
is not too large. This parameter is not used with
<a class="reference internal" href="#mdp-pull-coord1-geometry"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-geometry</span></code></a> cylinder. A value of -1 turns on cosine
weighting, which is useful for a group of molecules in a periodic
system, <em>e.g.</em> a water slab (see Engin et al. J. Chem. Phys. B
2010).</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-coord1-type">
<span class="sig-name descname"><span class="pre">pull-coord1-type</span></span><a class="headerlink" href="#mdp-pull-coord1-type" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-coord1-type-umbrella">
<span id="mdp-value-pull-coord1-type=umbrella"></span><span class="sig-name descname"><span class="pre">umbrella</span></span><a class="headerlink" href="#mdp-value-pull-coord1-type-umbrella" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Center of mass pulling using an umbrella potential between the
reference group and one or more groups.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-coord1-type-constraint">
<span id="mdp-value-pull-coord1-type=constraint"></span><span class="sig-name descname"><span class="pre">constraint</span></span><a class="headerlink" href="#mdp-value-pull-coord1-type-constraint" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Center of mass pulling using a constraint between the reference
group and one or more groups. The setup is identical to the
option umbrella, except for the fact that a rigid constraint is
applied instead of a harmonic potential. Note that this type is
not supported in combination with multiple time stepping.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-coord1-type-constant-force">
<span id="mdp-value-pull-coord1-type=constant-force"></span><span class="sig-name descname"><span class="pre">constant-force</span></span><a class="headerlink" href="#mdp-value-pull-coord1-type-constant-force" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Center of mass pulling using a linear potential and therefore a
constant force. For this option there is no reference position
and therefore the parameters <a class="reference internal" href="#mdp-pull-coord1-init"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-init</span></code></a> and
<a class="reference internal" href="#mdp-pull-coord1-rate"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-rate</span></code></a> are not used.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-coord1-type-flat-bottom">
<span id="mdp-value-pull-coord1-type=flat-bottom"></span><span class="sig-name descname"><span class="pre">flat-bottom</span></span><a class="headerlink" href="#mdp-value-pull-coord1-type-flat-bottom" title="Permalink to this definition">Â¶</a></dt>
<dd><p>At distances above <a class="reference internal" href="#mdp-pull-coord1-init"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-init</span></code></a> a harmonic potential
is applied, otherwise no potential is applied.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-coord1-type-flat-bottom-high">
<span id="mdp-value-pull-coord1-type=flat-bottom-high"></span><span class="sig-name descname"><span class="pre">flat-bottom-high</span></span><a class="headerlink" href="#mdp-value-pull-coord1-type-flat-bottom-high" title="Permalink to this definition">Â¶</a></dt>
<dd><p>At distances below <a class="reference internal" href="#mdp-pull-coord1-init"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-init</span></code></a> a harmonic potential
is applied, otherwise no potential is applied.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-coord1-type-external-potential">
<span id="mdp-value-pull-coord1-type=external-potential"></span><span class="sig-name descname"><span class="pre">external-potential</span></span><a class="headerlink" href="#mdp-value-pull-coord1-type-external-potential" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An external potential that needs to be provided by another
module.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-coord1-potential-provider">
<span class="sig-name descname"><span class="pre">pull-coord1-potential-provider</span></span><a class="headerlink" href="#mdp-pull-coord1-potential-provider" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The name of the external module that provides the potential for
the case where <a class="reference internal" href="#mdp-pull-coord1-type"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-type</span></code></a> is external-potential.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-coord1-geometry">
<span class="sig-name descname"><span class="pre">pull-coord1-geometry</span></span><a class="headerlink" href="#mdp-pull-coord1-geometry" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-coord1-geometry-distance">
<span id="mdp-value-pull-coord1-geometry=distance"></span><span class="sig-name descname"><span class="pre">distance</span></span><a class="headerlink" href="#mdp-value-pull-coord1-geometry-distance" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Pull along the vector connecting the two groups. Components can
be selected with <a class="reference internal" href="#mdp-pull-coord1-dim"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-dim</span></code></a>.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-coord1-geometry-direction">
<span id="mdp-value-pull-coord1-geometry=direction"></span><span class="sig-name descname"><span class="pre">direction</span></span><a class="headerlink" href="#mdp-value-pull-coord1-geometry-direction" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Pull in the direction of <a class="reference internal" href="#mdp-pull-coord1-vec"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-vec</span></code></a>.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-coord1-geometry-direction-periodic">
<span id="mdp-value-pull-coord1-geometry=direction-periodic"></span><span class="sig-name descname"><span class="pre">direction-periodic</span></span><a class="headerlink" href="#mdp-value-pull-coord1-geometry-direction-periodic" title="Permalink to this definition">Â¶</a></dt>
<dd><p>As <a class="reference internal" href="#mdp-value-pull-coord1-geometry-direction"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">pull-coord1-geometry=direction</span></code></a>, but does not apply
periodic box vector corrections to keep the distance within half
the box length. This is (only) useful for pushing groups apart
by more than half the box length by continuously changing the reference
location using a pull rate. With this geometry the box should not be
dynamic (<em>e.g.</em> no pressure scaling) in the pull dimensions and
the pull force is not added to the virial.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-coord1-geometry-direction-relative">
<span id="mdp-value-pull-coord1-geometry=direction-relative"></span><span class="sig-name descname"><span class="pre">direction-relative</span></span><a class="headerlink" href="#mdp-value-pull-coord1-geometry-direction-relative" title="Permalink to this definition">Â¶</a></dt>
<dd><p>As <a class="reference internal" href="#mdp-value-pull-coord1-geometry-direction"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">pull-coord1-geometry=direction</span></code></a>, but the pull vector is the vector
that points from the COM of a third to the COM of a fourth pull
group. This means that 4 groups need to be supplied in
<a class="reference internal" href="#mdp-pull-coord1-groups"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-groups</span></code></a>. Note that the pull force will give
rise to a torque on the pull vector, which is turn leads to
forces perpendicular to the pull vector on the two groups
defining the vector. If you want a pull group to move between
the two groups defining the vector, simply use the union of
these two groups as the reference group.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-coord1-geometry-cylinder">
<span id="mdp-value-pull-coord1-geometry=cylinder"></span><span class="sig-name descname"><span class="pre">cylinder</span></span><a class="headerlink" href="#mdp-value-pull-coord1-geometry-cylinder" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Designed for pulling with respect to a layer where the reference
COM is given by a local cylindrical part of the reference group.
The pulling is in the direction of <a class="reference internal" href="#mdp-pull-coord1-vec"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-vec</span></code></a>. From
the first of the two groups in <a class="reference internal" href="#mdp-pull-coord1-groups"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-groups</span></code></a> a
cylinder is selected around the axis going through the COM of
the second group with direction <a class="reference internal" href="#mdp-pull-coord1-vec"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-vec</span></code></a> with
radius <a class="reference internal" href="#mdp-pull-cylinder-r"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-cylinder-r</span></code></a>. Weights of the atoms decrease
continously to zero as the radial distance goes from 0 to
<a class="reference internal" href="#mdp-pull-cylinder-r"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-cylinder-r</span></code></a> (mass weighting is also used). The radial
dependence gives rise to radial forces on both pull groups.
Note that the radius should be smaller than half the box size.
For tilted cylinders they should be even smaller than half the
box size since the distance of an atom in the reference group
from the COM of the pull group has both a radial and an axial
component. This geometry is not supported with constraint
pulling.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-coord1-geometry-angle">
<span id="mdp-value-pull-coord1-geometry=angle"></span><span class="sig-name descname"><span class="pre">angle</span></span><a class="headerlink" href="#mdp-value-pull-coord1-geometry-angle" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Pull along an angle defined by four groups. The angle is
defined as the angle between two vectors: the vector connecting
the COM of the first group to the COM of the second group and
the vector connecting the COM of the third group to the COM of
the fourth group.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-coord1-geometry-angle-axis">
<span id="mdp-value-pull-coord1-geometry=angle-axis"></span><span class="sig-name descname"><span class="pre">angle-axis</span></span><a class="headerlink" href="#mdp-value-pull-coord1-geometry-angle-axis" title="Permalink to this definition">Â¶</a></dt>
<dd><p>As <a class="reference internal" href="#mdp-value-pull-coord1-geometry-angle"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">pull-coord1-geometry=angle</span></code></a> but the second vector is given by <a class="reference internal" href="#mdp-pull-coord1-vec"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-vec</span></code></a>.
Thus, only the two groups that define the first vector need to be given.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-coord1-geometry-dihedral">
<span id="mdp-value-pull-coord1-geometry=dihedral"></span><span class="sig-name descname"><span class="pre">dihedral</span></span><a class="headerlink" href="#mdp-value-pull-coord1-geometry-dihedral" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Pull along a dihedral angle defined by six groups. These pairwise
define three vectors: the vector connecting the COM of group 1
to the COM of group 2, the COM of group 3 to the COM of group 4,
and the COM of group 5 to the COM group 6. The dihedral angle is
then defined as the angle between two planes: the plane spanned by the
the two first vectors and the plane spanned the two last vectors.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-coord1-geometry-transformation">
<span id="mdp-value-pull-coord1-geometry=transformation"></span><span class="sig-name descname"><span class="pre">transformation</span></span><a class="headerlink" href="#mdp-value-pull-coord1-geometry-transformation" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Transforms other pull coordinates using a mathematical expression defined by <a class="reference internal" href="#mdp-pull-coord1-expression"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-expression</span></code></a>.
Pull coordinates of lower indices can be used as variables to this pull coordinate.
Thus, pull transformation coordinates should have a higher pull coordinate index
than all pull coordinates they transform.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-coord1-expression">
<span class="sig-name descname"><span class="pre">pull-coord1-expression</span></span><a class="headerlink" href="#mdp-pull-coord1-expression" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Mathematical expression to transform pull coordinates of lower indices to a new one.
The pull coordinates are referred to as variables in the equation so that
pull-coord1âs value becomes âx1â, pull-coord2 value becomes âx2â etc.
The mathematical expression are evaluated using muParser.
Only relevant if <a class="reference internal" href="#mdp-pull-coord1-geometry"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-geometry</span></code></a> is set to <code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">transformation</span></code>.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-coord1-dx">
<span class="sig-name descname"><span class="pre">pull-coord1-dx</span></span><a class="headerlink" href="#mdp-pull-coord1-dx" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1e-9)
Size of finite difference to use in numerical derivation of the pull coordinate
with respect to other pull coordinates.
The current implementation uses a simple first order finite difference method to perform derivation so that
fâ(x) = (f(x+dx)-f(x))/dx
Only relevant if <a class="reference internal" href="#mdp-pull-coord1-geometry"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-geometry</span></code></a> is set to <code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">transformation</span></code>.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-coord1-groups">
<span class="sig-name descname"><span class="pre">pull-coord1-groups</span></span><a class="headerlink" href="#mdp-pull-coord1-groups" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The group indices on which this pull coordinate will operate.
The number of group indices required is geometry dependent.
The first index can be 0, in which case an
absolute reference of <a class="reference internal" href="#mdp-pull-coord1-origin"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-origin</span></code></a> is used. With an
absolute reference the system is no longer translation invariant
and one should think about what to do with the center of mass
motion.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-coord1-dim">
<span class="sig-name descname"><span class="pre">pull-coord1-dim</span></span><a class="headerlink" href="#mdp-pull-coord1-dim" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(Y Y Y)
Selects the dimensions that this pull coordinate acts on and that
are printed to the output files when
<a class="reference internal" href="#mdp-pull-print-components"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-print-components</span></code></a> = <a class="reference internal" href="#mdp-value-pull-coord1-start-yes"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">pull-coord1-start=yes</span></code></a>. With
<a class="reference internal" href="#mdp-pull-coord1-geometry"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-geometry</span></code></a> = <a class="reference internal" href="#mdp-value-pull-coord1-geometry-distance"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">pull-coord1-geometry=distance</span></code></a>, only Cartesian
components set to Y contribute to the distance. Thus setting this
to Y Y N results in a distance in the x/y plane. With other
geometries all dimensions with non-zero entries in
<a class="reference internal" href="#mdp-pull-coord1-vec"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-vec</span></code></a> should be set to Y, the values for other
dimensions only affect the output.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-coord1-origin">
<span class="sig-name descname"><span class="pre">pull-coord1-origin</span></span><a class="headerlink" href="#mdp-pull-coord1-origin" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.0 0.0 0.0)
The pull reference position for use with an absolute reference.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-coord1-vec">
<span class="sig-name descname"><span class="pre">pull-coord1-vec</span></span><a class="headerlink" href="#mdp-pull-coord1-vec" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.0 0.0 0.0)
The pull direction. <a class="reference internal" href="../onlinehelp/gmx-grompp.html#gmx-grompp"><span class="std std-ref">gmx grompp</span></a> normalizes the vector.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-coord1-start">
<span class="sig-name descname"><span class="pre">pull-coord1-start</span></span><a class="headerlink" href="#mdp-pull-coord1-start" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-coord1-start-no">
<span id="mdp-value-pull-coord1-start=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-pull-coord1-start-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>do not modify <a class="reference internal" href="#mdp-pull-coord1-init"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-init</span></code></a></p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-pull-coord1-start-yes">
<span id="mdp-value-pull-coord1-start=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-pull-coord1-start-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>add the COM distance of the starting conformation to
<a class="reference internal" href="#mdp-pull-coord1-init"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-init</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-coord1-init">
<span class="sig-name descname"><span class="pre">pull-coord1-init</span></span><a class="headerlink" href="#mdp-pull-coord1-init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.0) [nm] or [deg]
The reference distance or reference angle at t=0.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-coord1-rate">
<span class="sig-name descname"><span class="pre">pull-coord1-rate</span></span><a class="headerlink" href="#mdp-pull-coord1-rate" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [nm/ps] or [deg/ps]
The rate of change of the reference position or reference angle.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-coord1-k">
<span class="sig-name descname"><span class="pre">pull-coord1-k</span></span><a class="headerlink" href="#mdp-pull-coord1-k" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [kJ mol<sup>-1</sup> nm<sup>-2</sup>] or [kJ mol<sup>-1</sup> nm<sup>-1</sup>] or
[kJ mol<sup>-1</sup> rad<sup>-2</sup>] or [kJ mol<sup>-1</sup> rad<sup>-1</sup>]
The force constant. For umbrella pulling this is the harmonic force
constant in kJ mol<sup>-1</sup> nm<sup>-2</sup> (or kJ mol<sup>-1</sup> rad<sup>-2</sup>
for angles). For constant force pulling this is the
force constant of the linear potential, and thus the negative (!)
of the constant force in kJ mol<sup>-1</sup> nm<sup>-1</sup>
(or kJ mol<sup>-1</sup> rad<sup>-1</sup> for angles).
Note that for angles the force constant is expressed in terms of radians
(while <a class="reference internal" href="#mdp-pull-coord1-init"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-init</span></code></a> and <a class="reference internal" href="#mdp-pull-coord1-rate"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-rate</span></code></a> are expressed in degrees).</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-pull-coord1-kB">
<span class="sig-name descname"><span class="pre">pull-coord1-kB</span></span><a class="headerlink" href="#mdp-pull-coord1-kB" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(pull-k1) [kJ mol<sup>-1</sup> nm<sup>-2</sup>] or [kJ mol<sup>-1</sup> nm<sup>-1</sup>]
or [kJ mol<sup>-1</sup> rad<sup>-2</sup>] or [kJ mol<sup>-1</sup> rad<sup>-1</sup>]
As <a class="reference internal" href="#mdp-pull-coord1-k"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-k</span></code></a>, but for state B. This is only used when
<a class="reference internal" href="#mdp-free-energy"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">free-energy</span></code></a> is turned on. The force constant is then (1 -
lambda) * <a class="reference internal" href="#mdp-pull-coord1-k"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-k</span></code></a> + lambda * <a class="reference internal" href="#mdp-pull-coord1-kB"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-kB</span></code></a>.</p>
</dd></dl>

</section>
<section id="awh-adaptive-biasing">
<h3>AWH adaptive biasing<a class="headerlink" href="#awh-adaptive-biasing" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh">
<span class="sig-name descname"><span class="pre">awh</span></span><a class="headerlink" href="#mdp-awh" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh-no">
<span id="mdp-value-awh=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-awh-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>No biasing.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh-yes">
<span id="mdp-value-awh=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-awh-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Adaptively bias a reaction coordinate using the AWH method and estimate
the corresponding PMF. The PMF and other AWH data are written to energy
file at an interval set by <a class="reference internal" href="#mdp-awh-nstout"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh-nstout</span></code></a> and can be extracted with
the <code class="docutils literal notranslate"><span class="pre">gmx</span> <span class="pre">awh</span></code> tool. The AWH coordinate can be
multidimensional and is defined by mapping each dimension to a pull coordinate index.
This is only allowed if <a class="reference internal" href="#mdp-value-pull-coord1-type-external-potential"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">pull-coord1-type=external-potential</span></code></a> and
<a class="reference internal" href="#mdp-pull-coord1-potential-provider"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-potential-provider</span></code></a> = <code class="docutils literal notranslate"><span class="pre">awh</span></code> for the concerned pull coordinate
indices. Pull geometry âdirection-periodicâ is not supported by AWH.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh-potential">
<span class="sig-name descname"><span class="pre">awh-potential</span></span><a class="headerlink" href="#mdp-awh-potential" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh-potential-convolved">
<span id="mdp-value-awh-potential=convolved"></span><span class="sig-name descname"><span class="pre">convolved</span></span><a class="headerlink" href="#mdp-value-awh-potential-convolved" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The applied biasing potential is the convolution of the bias function and a
set of harmonic umbrella potentials (see <a class="reference internal" href="#mdp-value-awh-potential-umbrella"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">awh-potential=umbrella</span></code></a> below). This results
in a smooth potential function and force. The resolution of the potential is set
by the force constant of each umbrella, see <a class="reference internal" href="#mdp-awh1-dim1-force-constant"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-dim1-force-constant</span></code></a>. This option is not
compatible with using the free energy lambda state as an AWH reaction coordinate.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh-potential-umbrella">
<span id="mdp-value-awh-potential=umbrella"></span><span class="sig-name descname"><span class="pre">umbrella</span></span><a class="headerlink" href="#mdp-value-awh-potential-umbrella" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The potential bias is applied by controlling the position of an harmonic potential
using Monte-Carlo sampling.  The force constant is set with
<a class="reference internal" href="#mdp-awh1-dim1-force-constant"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-dim1-force-constant</span></code></a>. The umbrella location
is sampled using Monte-Carlo every <a class="reference internal" href="#mdp-awh-nstsample"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh-nstsample</span></code></a> steps.
This is option is required when using the free energy lambda state as an AWH reaction coordinate.
Apart from that, this option is mainly for comparison
and testing purposes as there are no advantages to using an umbrella.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh-share-multisim">
<span class="sig-name descname"><span class="pre">awh-share-multisim</span></span><a class="headerlink" href="#mdp-awh-share-multisim" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh-share-multisim-no">
<span id="mdp-value-awh-share-multisim=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-awh-share-multisim-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>AWH will not share biases across simulations started with
<a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> option <code class="docutils literal notranslate"><span class="pre">-multidir</span></code>. The biases will be independent.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh-share-multisim-yes">
<span id="mdp-value-awh-share-multisim=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-awh-share-multisim-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>With <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> and option <code class="docutils literal notranslate"><span class="pre">-multidir</span></code> the bias and PMF estimates
for biases with <a class="reference internal" href="#mdp-awh1-share-group"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-share-group</span></code></a> &gt;0 will be shared across simulations
with the biases with the same <a class="reference internal" href="#mdp-awh1-share-group"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-share-group</span></code></a> value.
The simulations should have the same AWH settings for sharing to make sense.
<a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> will check whether the simulations are technically
compatible for sharing, but the user should check that bias sharing
physically makes sense.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh-seed">
<span class="sig-name descname"><span class="pre">awh-seed</span></span><a class="headerlink" href="#mdp-awh-seed" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(-1) Random seed for Monte-Carlo sampling the umbrella position,
where -1 indicates to generate a seed. Only used with
<a class="reference internal" href="#mdp-value-awh-potential-umbrella"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">awh-potential=umbrella</span></code></a>.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh-nstout">
<span class="sig-name descname"><span class="pre">awh-nstout</span></span><a class="headerlink" href="#mdp-awh-nstout" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(100000)
Number of steps between printing AWH data to the energy file, should be
a multiple of <a class="reference internal" href="#mdp-nstenergy"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstenergy</span></code></a>.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh-nstsample">
<span class="sig-name descname"><span class="pre">awh-nstsample</span></span><a class="headerlink" href="#mdp-awh-nstsample" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(10)
Number of steps between sampling of the coordinate value. This sampling
is the basis for updating the bias and estimating the PMF and other AWH observables.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh-nsamples-update">
<span class="sig-name descname"><span class="pre">awh-nsamples-update</span></span><a class="headerlink" href="#mdp-awh-nsamples-update" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(10)
The number of coordinate samples used for each AWH update.
The update interval in steps is <a class="reference internal" href="#mdp-awh-nstsample"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh-nstsample</span></code></a> times this value.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh-nbias">
<span class="sig-name descname"><span class="pre">awh-nbias</span></span><a class="headerlink" href="#mdp-awh-nbias" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1)
The number of biases, each acting on its own coordinate.
The following options should be specified
for each bias although below only the options for bias number 1 is shown. Options for
other bias indices are  obtained by replacing â1â by the bias index.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh1-error-init">
<span class="sig-name descname"><span class="pre">awh1-error-init</span></span><a class="headerlink" href="#mdp-awh1-error-init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(10.0) [kJ mol<sup>-1</sup>]
Estimated initial average error of the PMF for this bias. This value together with the
given diffusion constant(s) <a class="reference internal" href="#mdp-awh1-dim1-diffusion"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-dim1-diffusion</span></code></a> determine the initial biasing rate.
The error is obviously not known <em>a priori</em>. Only a rough estimate of <a class="reference internal" href="#mdp-awh1-error-init"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-error-init</span></code></a>
is needed however.
As a  general guideline, leave <a class="reference internal" href="#mdp-awh1-error-init"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-error-init</span></code></a> to its default value when starting a new
simulation. On the other hand, when there is <em>a priori</em> knowledge of the PMF (e.g. when
an initial PMF estimate is provided, see the <a class="reference internal" href="#mdp-awh1-user-data"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-user-data</span></code></a> option)
then <a class="reference internal" href="#mdp-awh1-error-init"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-error-init</span></code></a> should reflect that knowledge.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh1-growth">
<span class="sig-name descname"><span class="pre">awh1-growth</span></span><a class="headerlink" href="#mdp-awh1-growth" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh1-growth-exp-linear">
<span id="mdp-value-awh1-growth=exp-linear"></span><span class="sig-name descname"><span class="pre">exp-linear</span></span><a class="headerlink" href="#mdp-value-awh1-growth-exp-linear" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<p>Each bias keeps a reference weight histogram for the coordinate samples.
Its size sets the magnitude of the bias function and free energy estimate updates
(few samples corresponds to large updates and vice versa).
Thus, its growth rate sets the maximum convergence rate.
By default, there is an initial stage in which the histogram grows close to exponentially (but slower than the sampling rate).
In the final stage that follows, the growth rate is linear and equal to the sampling rate (set by <a class="reference internal" href="#mdp-awh-nstsample"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh-nstsample</span></code></a>).
The initial stage is typically necessary for efficient convergence when starting a new simulation where
high free energy barriers have not yet been flattened by the bias.</p>
<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh1-growth-linear">
<span id="mdp-value-awh1-growth=linear"></span><span class="sig-name descname"><span class="pre">linear</span></span><a class="headerlink" href="#mdp-value-awh1-growth-linear" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<p>As <a class="reference internal" href="#mdp-value-awh1-growth-exp-linear"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">awh1-growth=exp-linear</span></code></a> but skip the initial stage. This may be useful if there is <em>a priori</em>
knowledge (see <a class="reference internal" href="#mdp-awh1-error-init"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-error-init</span></code></a>) which eliminates the need for an initial stage. This is also
the setting compatible with <a class="reference internal" href="#mdp-value-awh1-target-local-boltzmann"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">awh1-target=local-boltzmann</span></code></a>.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh1-equilibrate-histogram">
<span class="sig-name descname"><span class="pre">awh1-equilibrate-histogram</span></span><a class="headerlink" href="#mdp-awh1-equilibrate-histogram" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh1-equilibrate-histogram-no">
<span id="mdp-value-awh1-equilibrate-histogram=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-awh1-equilibrate-histogram-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Do not equilibrate histogram.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh1-equilibrate-histogram-yes">
<span id="mdp-value-awh1-equilibrate-histogram=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-awh1-equilibrate-histogram-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Before entering the initial stage (see <a class="reference internal" href="#mdp-value-awh1-growth-exp-linear"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">awh1-growth=exp-linear</span></code></a>), make sure the
histogram of sampled weights is following the target distribution closely enough (specifically,
at least 80% of the target region needs to have a local relative error of less than 20%). This
option would typically only be used when <a class="reference internal" href="#mdp-awh1-share-group"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-share-group</span></code></a> &gt; 0
and the initial configurations poorly represent the target
distribution.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh1-target">
<span class="sig-name descname"><span class="pre">awh1-target</span></span><a class="headerlink" href="#mdp-awh1-target" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh1-target-constant">
<span id="mdp-value-awh1-target=constant"></span><span class="sig-name descname"><span class="pre">constant</span></span><a class="headerlink" href="#mdp-value-awh1-target-constant" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The bias is tuned towards a constant (uniform) coordinate distribution
in the defined sampling interval (defined by  [<a class="reference internal" href="#mdp-awh1-dim1-start"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-dim1-start</span></code></a>, <a class="reference internal" href="#mdp-awh1-dim1-end"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-dim1-end</span></code></a>]).</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh1-target-cutoff">
<span id="mdp-value-awh1-target=cutoff"></span><span class="sig-name descname"><span class="pre">cutoff</span></span><a class="headerlink" href="#mdp-value-awh1-target-cutoff" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#mdp-value-awh1-target-constant"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">awh1-target=constant</span></code></a>, but the target
distribution is proportional to 1/(1 + exp(F - <a class="reference internal" href="#mdp-value-awh1-target-cutoff"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">awh1-target=cutoff</span></code></a>)),
where F is the free energy relative to the estimated global minimum.
This provides a smooth switch of a flat target distribution in
regions with free energy lower than the cut-off to a Boltzmann
distribution in regions with free energy higher than the cut-off.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh1-target-boltzmann">
<span id="mdp-value-awh1-target=boltzmann"></span><span class="sig-name descname"><span class="pre">boltzmann</span></span><a class="headerlink" href="#mdp-value-awh1-target-boltzmann" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The target distribution is a Boltzmann distribtution with a scaled beta (inverse temperature)
factor given by <a class="reference internal" href="#mdp-awh1-target-beta-scaling"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-target-beta-scaling</span></code></a>. <em>E.g.</em>, a value of 0.1
would give the same coordinate distribution as sampling with a simulation temperature
scaled by 10.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh1-target-local-boltzmann">
<span id="mdp-value-awh1-target=local-boltzmann"></span><span class="sig-name descname"><span class="pre">local-boltzmann</span></span><a class="headerlink" href="#mdp-value-awh1-target-local-boltzmann" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Same target distribution and use of <a class="reference internal" href="#mdp-awh1-target-beta-scaling"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-target-beta-scaling</span></code></a>
but the convergence towards the target distribution is inherently local <em>i.e.</em>, the rate of
change of the bias only depends on the local sampling. This local convergence property is
only compatible with <a class="reference internal" href="#mdp-value-awh1-growth-linear"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">awh1-growth=linear</span></code></a>, since for
<a class="reference internal" href="#mdp-value-awh1-growth-exp-linear"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">awh1-growth=exp-linear</span></code></a> histograms are globally rescaled in the initial stage.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh1-target-beta-scaling">
<span class="sig-name descname"><span class="pre">awh1-target-beta-scaling</span></span><a class="headerlink" href="#mdp-awh1-target-beta-scaling" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0)
For <a class="reference internal" href="#mdp-value-awh1-target-boltzmann"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">awh1-target=boltzmann</span></code></a> and <a class="reference internal" href="#mdp-value-awh1-target-local-boltzmann"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">awh1-target=local-boltzmann</span></code></a>
it is the unitless beta scaling factor taking values in (0,1).</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh1-target-cutoff">
<span class="sig-name descname"><span class="pre">awh1-target-cutoff</span></span><a class="headerlink" href="#mdp-awh1-target-cutoff" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [kJ mol<sup>-1</sup>]
For <a class="reference internal" href="#mdp-value-awh1-target-cutoff"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">awh1-target=cutoff</span></code></a> this is the cutoff, should be &gt; 0.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh1-user-data">
<span class="sig-name descname"><span class="pre">awh1-user-data</span></span><a class="headerlink" href="#mdp-awh1-user-data" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh1-user-data-no">
<span id="mdp-value-awh1-user-data=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-awh1-user-data-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Initialize the PMF and target distribution with default values.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh1-user-data-yes">
<span id="mdp-value-awh1-user-data=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-awh1-user-data-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Initialize the PMF and target distribution with user provided data. For <a class="reference internal" href="#mdp-awh-nbias"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh-nbias</span></code></a> = 1,
<a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> will expect a file <code class="docutils literal notranslate"><span class="pre">awhinit.xvg</span></code> to be present in the run directory.
For multiple biases, <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> expects files <code class="docutils literal notranslate"><span class="pre">awhinit1.xvg</span></code>, <code class="docutils literal notranslate"><span class="pre">awhinit2.xvg</span></code>, etc.
The file name can be changed with the <code class="docutils literal notranslate"><span class="pre">-awh</span></code> option.
The first <a class="reference internal" href="#mdp-awh1-ndim"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-ndim</span></code></a> columns of
each input file should contain the coordinate values, such that each row defines a point in
coordinate space. Column <a class="reference internal" href="#mdp-awh1-ndim"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-ndim</span></code></a> + 1 should contain the PMF value (in kT) for each point.
The target distribution column can either follow the PMF (column  <a class="reference internal" href="#mdp-awh1-ndim"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-ndim</span></code></a> + 2) or
be in the same column as written by <a class="reference internal" href="../onlinehelp/gmx-awh.html#gmx-awh"><span class="std std-ref">gmx awh</span></a>.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh1-share-group">
<span class="sig-name descname"><span class="pre">awh1-share-group</span></span><a class="headerlink" href="#mdp-awh1-share-group" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh1-share-group-0">
<span id="mdp-value-awh1-share-group=0"></span><span class="sig-name descname"><span class="pre">0</span></span><a class="headerlink" href="#mdp-value-awh1-share-group-0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Do not share the bias.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh1-share-group-positive">
<span id="mdp-value-awh1-share-group=positive"></span><span class="sig-name descname"><span class="pre">positive</span></span><a class="headerlink" href="#mdp-value-awh1-share-group-positive" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Share the bias and PMF estimates between simulations. This currently
only works between biases with the same index. Note that currently
sharing within a single simulation is not supported.
The bias will be shared across simulations that specify the same
value for <a class="reference internal" href="#mdp-awh1-share-group"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-share-group</span></code></a>. To enable this, use
<a class="reference internal" href="#mdp-value-awh-share-multisim-yes"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">awh-share-multisim=yes</span></code></a> and the <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> option
<code class="docutils literal notranslate"><span class="pre">-multidir</span></code>.
Sharing may increase convergence initially, although the starting configurations
can be critical, especially when sharing between many biases.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh1-ndim">
<span class="sig-name descname"><span class="pre">awh1-ndim</span></span><a class="headerlink" href="#mdp-awh1-ndim" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1) [integer]
Number of dimensions of the coordinate, each dimension maps to 1 pull coordinate.
The following options should be specified for each such dimension. Below only
the options for dimension number 1 is shown. Options for other dimension indices are
obtained by replacing â1â by the dimension index.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh1-dim1-coord-provider">
<span class="sig-name descname"><span class="pre">awh1-dim1-coord-provider</span></span><a class="headerlink" href="#mdp-awh1-dim1-coord-provider" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh1-dim1-coord-provider-pull">
<span id="mdp-value-awh1-dim1-coord-provider=pull"></span><span class="sig-name descname"><span class="pre">pull</span></span><a class="headerlink" href="#mdp-value-awh1-dim1-coord-provider-pull" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The pull module is providing the reaction coordinate for this dimension.
With multiple time-stepping, AWH and pull should be in the same MTS level.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-awh1-dim1-coord-provider-fep-lambda">
<span id="mdp-value-awh1-dim1-coord-provider=fep-lambda"></span><span class="sig-name descname"><span class="pre">fep-lambda</span></span><a class="headerlink" href="#mdp-value-awh1-dim1-coord-provider-fep-lambda" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The free energy lambda state is the reaction coordinate for this dimension.
The lambda states to use are specified by <a class="reference internal" href="#mdp-fep-lambdas"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">fep-lambdas</span></code></a>, <a class="reference internal" href="#mdp-vdw-lambdas"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">vdw-lambdas</span></code></a>,
<a class="reference internal" href="#mdp-coul-lambdas"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">coul-lambdas</span></code></a> etc. This is not compatible with delta-lambda. It also requires
calc-lambda-neighbors to be -1. With multiple time-stepping, AWH should
be in the slow level. This option requires <a class="reference internal" href="#mdp-value-awh-potential-umbrella"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">awh-potential=umbrella</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh1-dim1-coord-index">
<span class="sig-name descname"><span class="pre">awh1-dim1-coord-index</span></span><a class="headerlink" href="#mdp-awh1-dim1-coord-index" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1)
Index of the pull coordinate defining this coordinate dimension.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh1-dim1-force-constant">
<span class="sig-name descname"><span class="pre">awh1-dim1-force-constant</span></span><a class="headerlink" href="#mdp-awh1-dim1-force-constant" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [kJ mol<sup>-1</sup> nm<sup>-2</sup>] or [kJ mol<sup>-1</sup> rad<sup>-2</sup>]
Force constant for the (convolved) umbrella potential(s) along this
coordinate dimension.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh1-dim1-start">
<span class="sig-name descname"><span class="pre">awh1-dim1-start</span></span><a class="headerlink" href="#mdp-awh1-dim1-start" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.0) [nm] or [deg]
Start value of the sampling interval along this dimension. The range of allowed
values depends on the relevant pull geometry (see <a class="reference internal" href="#mdp-pull-coord1-geometry"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">pull-coord1-geometry</span></code></a>).
For dihedral geometries <a class="reference internal" href="#mdp-awh1-dim1-start"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-dim1-start</span></code></a> greater than <a class="reference internal" href="#mdp-awh1-dim1-end"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-dim1-end</span></code></a>
is allowed. The interval will then wrap around from +period/2 to -period/2.
For the direction geometry, the dimension is made periodic when
the direction is along a box vector and covers more than 95%
of the box length. Note that one should not apply pressure coupling
along a periodic dimension.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh1-dim1-end">
<span class="sig-name descname"><span class="pre">awh1-dim1-end</span></span><a class="headerlink" href="#mdp-awh1-dim1-end" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.0) [nm] or [deg]
End value defining the sampling interval together with <a class="reference internal" href="#mdp-awh1-dim1-start"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-dim1-start</span></code></a>.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh1-dim1-diffusion">
<span class="sig-name descname"><span class="pre">awh1-dim1-diffusion</span></span><a class="headerlink" href="#mdp-awh1-dim1-diffusion" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(10<sup>-5</sup>) [nm<sup>2</sup>/ps], [rad<sup>2</sup>/ps] or [ps<sup>-1</sup>]
Estimated diffusion constant for this coordinate dimension determining the initial
biasing rate. This needs only be a rough estimate and should not critically
affect the results unless it is set to something very low, leading to slow convergence,
or very high, forcing the system far from equilibrium. Not setting this value
explicitly generates a warning.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-awh1-dim1-cover-diameter">
<span class="sig-name descname"><span class="pre">awh1-dim1-cover-diameter</span></span><a class="headerlink" href="#mdp-awh1-dim1-cover-diameter" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.0) [nm] or [deg]
Diameter that needs to be sampled by a single simulation around a coordinate value
before the point is considered covered in the initial stage (see <a class="reference internal" href="#mdp-value-awh1-growth-exp-linear"><code class="xref std std-mdp-value docutils literal notranslate"><span class="pre">awh1-growth=exp-linear</span></code></a>).
A value &gt; 0  ensures that for each covering there is a continuous transition of this diameter
across each coordinate value.
This is trivially true for independent simulations but not for for multiple bias-sharing simulations
(<a class="reference internal" href="#mdp-awh1-share-group"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">awh1-share-group</span></code></a>&gt;0).
For a diameter = 0, covering occurs as soon as the simulations have sampled the whole interval, which
for many sharing simulations does not guarantee transitions across free energy barriers.
On the other hand, when the diameter &gt;= the sampling interval length, covering occurs when a single simulation
has independently sampled the whole interval.</p>
</dd></dl>

</section>
<section id="enforced-rotation">
<h3>Enforced rotation<a class="headerlink" href="#enforced-rotation" title="Permalink to this headline">Â¶</a></h3>
<p>These <a class="reference internal" href="../reference-manual/file-formats.html#mdp"><span class="std std-ref">mdp</span></a> parameters can be used enforce the rotation of a group of atoms,
e.g. a protein subunit. The <a class="reference external" href="../manual-2022.4.pdf">reference manual</a> describes in detail 13 different potentials
that can be used to achieve such a rotation.</p>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rotation">
<span class="sig-name descname"><span class="pre">rotation</span></span><a class="headerlink" href="#mdp-rotation" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-rotation-no">
<span id="mdp-value-rotation=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-rotation-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>No enforced rotation will be applied. All enforced rotation options will
be ignored (and if present in the <a class="reference internal" href="../reference-manual/file-formats.html#mdp"><span class="std std-ref">mdp</span></a> file, they unfortunately
generate warnings).</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-rotation-yes">
<span id="mdp-value-rotation=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-rotation-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Apply the rotation potential specified by <a class="reference internal" href="#mdp-rot-type0"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rot-type0</span></code></a> to the group of atoms given
under the <a class="reference internal" href="#mdp-rot-group0"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">rot-group0</span></code></a> option.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rot-ngroups">
<span class="sig-name descname"><span class="pre">rot-ngroups</span></span><a class="headerlink" href="#mdp-rot-ngroups" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1)
Number of rotation groups.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rot-group0">
<span class="sig-name descname"><span class="pre">rot-group0</span></span><a class="headerlink" href="#mdp-rot-group0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Name of rotation group 0 in the index file.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rot-type0">
<span class="sig-name descname"><span class="pre">rot-type0</span></span><a class="headerlink" href="#mdp-rot-type0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(iso)
Type of rotation potential that is applied to rotation group 0. Can be of of the following:
<code class="docutils literal notranslate"><span class="pre">iso</span></code>, <code class="docutils literal notranslate"><span class="pre">iso-pf</span></code>, <code class="docutils literal notranslate"><span class="pre">pm</span></code>, <code class="docutils literal notranslate"><span class="pre">pm-pf</span></code>, <code class="docutils literal notranslate"><span class="pre">rm</span></code>, <code class="docutils literal notranslate"><span class="pre">rm-pf</span></code>, <code class="docutils literal notranslate"><span class="pre">rm2</span></code>, <code class="docutils literal notranslate"><span class="pre">rm2-pf</span></code>,
<code class="docutils literal notranslate"><span class="pre">flex</span></code>, <code class="docutils literal notranslate"><span class="pre">flex-t</span></code>, <code class="docutils literal notranslate"><span class="pre">flex2</span></code>, or <code class="docutils literal notranslate"><span class="pre">flex2-t</span></code>.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rot-massw0">
<span class="sig-name descname"><span class="pre">rot-massw0</span></span><a class="headerlink" href="#mdp-rot-massw0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(no)
Use mass weighted rotation group positions.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rot-vec0">
<span class="sig-name descname"><span class="pre">rot-vec0</span></span><a class="headerlink" href="#mdp-rot-vec0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1.0 0.0 0.0)
Rotation vector, will get normalized.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rot-pivot0">
<span class="sig-name descname"><span class="pre">rot-pivot0</span></span><a class="headerlink" href="#mdp-rot-pivot0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.0 0.0 0.0) [nm]
Pivot point for the potentials <code class="docutils literal notranslate"><span class="pre">iso</span></code>, <code class="docutils literal notranslate"><span class="pre">pm</span></code>, <code class="docutils literal notranslate"><span class="pre">rm</span></code>, and <code class="docutils literal notranslate"><span class="pre">rm2</span></code>.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rot-rate0">
<span class="sig-name descname"><span class="pre">rot-rate0</span></span><a class="headerlink" href="#mdp-rot-rate0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [degree ps<sup>-1</sup>]
Reference rotation rate of group 0.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rot-k0">
<span class="sig-name descname"><span class="pre">rot-k0</span></span><a class="headerlink" href="#mdp-rot-k0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [kJ mol<sup>-1</sup> nm<sup>-2</sup>]
Force constant for group 0.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rot-slab-dist0">
<span class="sig-name descname"><span class="pre">rot-slab-dist0</span></span><a class="headerlink" href="#mdp-rot-slab-dist0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1.5) [nm]
Slab distance, if a flexible axis rotation type was chosen.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rot-min-gauss0">
<span class="sig-name descname"><span class="pre">rot-min-gauss0</span></span><a class="headerlink" href="#mdp-rot-min-gauss0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.001)
Minimum value (cutoff) of Gaussian function for the force to be evaluated
(for the flexible axis potentials).</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rot-eps0">
<span class="sig-name descname"><span class="pre">rot-eps0</span></span><a class="headerlink" href="#mdp-rot-eps0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.0001) [nm<sup>2</sup>]
Value of additive constant epsilon for <code class="docutils literal notranslate"><span class="pre">rm2*</span></code> and <code class="docutils literal notranslate"><span class="pre">flex2*</span></code> potentials.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rot-fit-method0">
<span class="sig-name descname"><span class="pre">rot-fit-method0</span></span><a class="headerlink" href="#mdp-rot-fit-method0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(rmsd)
Fitting method when determining the actual angle of a rotation group
(can be one of <code class="docutils literal notranslate"><span class="pre">rmsd</span></code>, <code class="docutils literal notranslate"><span class="pre">norm</span></code>, or <code class="docutils literal notranslate"><span class="pre">potential</span></code>).</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rot-potfit-nsteps0">
<span class="sig-name descname"><span class="pre">rot-potfit-nsteps0</span></span><a class="headerlink" href="#mdp-rot-potfit-nsteps0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(21)
For fit type <code class="docutils literal notranslate"><span class="pre">potential</span></code>, the number of angular positions around the reference angle for which the
rotation potential is evaluated.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rot-potfit-step0">
<span class="sig-name descname"><span class="pre">rot-potfit-step0</span></span><a class="headerlink" href="#mdp-rot-potfit-step0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.25)
For fit type <code class="docutils literal notranslate"><span class="pre">potential</span></code>, the distance in degrees between two angular positions.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rot-nstrout">
<span class="sig-name descname"><span class="pre">rot-nstrout</span></span><a class="headerlink" href="#mdp-rot-nstrout" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(100)
Output frequency (in steps) for the angle of the rotation group, as well as for the torque
and the rotation potential energy.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-rot-nstsout">
<span class="sig-name descname"><span class="pre">rot-nstsout</span></span><a class="headerlink" href="#mdp-rot-nstsout" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1000)
Output frequency for per-slab data of the flexible axis potentials, i.e. angles, torques and slab centers.</p>
</dd></dl>

</section>
<section id="nmr-refinement">
<h3>NMR refinement<a class="headerlink" href="#nmr-refinement" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-disre">
<span class="sig-name descname"><span class="pre">disre</span></span><a class="headerlink" href="#mdp-disre" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-disre-no">
<span id="mdp-value-disre=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-disre-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>ignore distance restraint information in topology file</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-disre-simple">
<span id="mdp-value-disre=simple"></span><span class="sig-name descname"><span class="pre">simple</span></span><a class="headerlink" href="#mdp-value-disre-simple" title="Permalink to this definition">Â¶</a></dt>
<dd><p>simple (per-molecule) distance restraints.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-disre-ensemble">
<span id="mdp-value-disre=ensemble"></span><span class="sig-name descname"><span class="pre">ensemble</span></span><a class="headerlink" href="#mdp-value-disre-ensemble" title="Permalink to this definition">Â¶</a></dt>
<dd><p>distance restraints over an ensemble of molecules in one
simulation box. Normally, one would perform ensemble averaging
over multiple simulations, using <code class="docutils literal notranslate"><span class="pre">mdrun</span>
<span class="pre">-multidir</span></code>. The environment
variable <code class="docutils literal notranslate"><span class="pre">GMX_DISRE_ENSEMBLE_SIZE</span></code> sets the number of systems
within each ensemble (usually equal to the number of directories
supplied to <code class="docutils literal notranslate"><span class="pre">mdrun</span> <span class="pre">-multidir</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-disre-weighting">
<span class="sig-name descname"><span class="pre">disre-weighting</span></span><a class="headerlink" href="#mdp-disre-weighting" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-disre-weighting-equal">
<span id="mdp-value-disre-weighting=equal"></span><span class="sig-name descname"><span class="pre">equal</span></span><a class="headerlink" href="#mdp-value-disre-weighting-equal" title="Permalink to this definition">Â¶</a></dt>
<dd><p>divide the restraint force equally over all atom pairs in the
restraint</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-disre-weighting-conservative">
<span id="mdp-value-disre-weighting=conservative"></span><span class="sig-name descname"><span class="pre">conservative</span></span><a class="headerlink" href="#mdp-value-disre-weighting-conservative" title="Permalink to this definition">Â¶</a></dt>
<dd><p>the forces are the derivative of the restraint potential, this
results in an weighting of the atom pairs to the reciprocal
seventh power of the displacement. The forces are conservative
when <a class="reference internal" href="#mdp-disre-tau"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">disre-tau</span></code></a> is zero.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-disre-mixed">
<span class="sig-name descname"><span class="pre">disre-mixed</span></span><a class="headerlink" href="#mdp-disre-mixed" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-disre-mixed-no">
<span id="mdp-value-disre-mixed=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-disre-mixed-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>the violation used in the calculation of the restraint force is
the time-averaged violation</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-disre-mixed-yes">
<span id="mdp-value-disre-mixed=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-disre-mixed-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>the violation used in the calculation of the restraint force is
the square root of the product of the time-averaged violation
and the instantaneous violation</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-disre-fc">
<span class="sig-name descname"><span class="pre">disre-fc</span></span><a class="headerlink" href="#mdp-disre-fc" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1000) [kJ mol<sup>-1</sup> nm<sup>-2</sup>]
force constant for distance restraints, which is multiplied by a
(possibly) different factor for each restraint given in the <code class="docutils literal notranslate"><span class="pre">fac</span></code>
column of the interaction in the topology file.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-disre-tau">
<span class="sig-name descname"><span class="pre">disre-tau</span></span><a class="headerlink" href="#mdp-disre-tau" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [ps]
time constant for distance restraints running average. A value of
zero turns off time averaging.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nstdisreout">
<span class="sig-name descname"><span class="pre">nstdisreout</span></span><a class="headerlink" href="#mdp-nstdisreout" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(100) [steps]
period between steps when the running time-averaged and
instantaneous distances of all atom pairs involved in restraints
are written to the energy file (can make the energy file very
large)</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-orire">
<span class="sig-name descname"><span class="pre">orire</span></span><a class="headerlink" href="#mdp-orire" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-orire-no">
<span id="mdp-value-orire=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-orire-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>ignore orientation restraint information in topology file</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-orire-yes">
<span id="mdp-value-orire=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-orire-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>use orientation restraints, ensemble averaging can be performed
with <code class="docutils literal notranslate"><span class="pre">mdrun</span> <span class="pre">-multidir</span></code></p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-orire-fc">
<span class="sig-name descname"><span class="pre">orire-fc</span></span><a class="headerlink" href="#mdp-orire-fc" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [kJ mol<sup>-1</sup>]
force constant for orientation restraints, which is multiplied by a
(possibly) different weight factor for each restraint, can be set
to zero to obtain the orientations from a free simulation</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-orire-tau">
<span class="sig-name descname"><span class="pre">orire-tau</span></span><a class="headerlink" href="#mdp-orire-tau" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [ps]
time constant for orientation restraints running average. A value
of zero turns off time averaging.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-orire-fitgrp">
<span class="sig-name descname"><span class="pre">orire-fitgrp</span></span><a class="headerlink" href="#mdp-orire-fitgrp" title="Permalink to this definition">Â¶</a></dt>
<dd><p>fit group for orientation restraining. This group of atoms is used
to determine the rotation <strong>R</strong> of the system with respect to the
reference orientation. The reference orientation is the starting
conformation of the first subsystem. For a protein, backbone is a
reasonable choice</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nstorireout">
<span class="sig-name descname"><span class="pre">nstorireout</span></span><a class="headerlink" href="#mdp-nstorireout" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(100) [steps]
period between steps when the running time-averaged and
instantaneous orientations for all restraints, and the molecular
order tensor are written to the energy file (can make the energy
file very large)</p>
</dd></dl>

</section>
<section id="free-energy-calculations">
<h3>Free energy calculations<a class="headerlink" href="#free-energy-calculations" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-free-energy">
<span class="sig-name descname"><span class="pre">free-energy</span></span><a class="headerlink" href="#mdp-free-energy" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-free-energy-no">
<span id="mdp-value-free-energy=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-free-energy-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Only use topology A.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-free-energy-yes">
<span id="mdp-value-free-energy=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-free-energy-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Interpolate between topology A (lambda=0) to topology B
(lambda=1) and write the derivative of the Hamiltonian with
respect to lambda (as specified with <a class="reference internal" href="#mdp-dhdl-derivatives"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">dhdl-derivatives</span></code></a>),
or the Hamiltonian differences with respect to other lambda
values (as specified with foreign lambda) to the energy file
and/or to <code class="docutils literal notranslate"><span class="pre">dhdl.xvg</span></code>, where they can be processed by, for
example <a class="reference internal" href="../onlinehelp/gmx-bar.html#gmx-bar"><span class="std std-ref">gmx bar</span></a>. The potentials, bond-lengths and angles
are interpolated linearly as described in the manual. When
<a class="reference internal" href="#mdp-sc-alpha"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">sc-alpha</span></code></a> is larger than zero, soft-core potentials are
used for the LJ and Coulomb interactions.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-expanded">
<span class="sig-name descname"><span class="pre">expanded</span></span><a class="headerlink" href="#mdp-expanded" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Turns on expanded ensemble simulation, where the alchemical state
becomes a dynamic variable, allowing jumping between different
Hamiltonians. See the expanded ensemble options for controlling how
expanded ensemble simulations are performed. The different
Hamiltonians used in expanded ensemble simulations are defined by
the other free energy options.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-init-lambda">
<span class="sig-name descname"><span class="pre">init-lambda</span></span><a class="headerlink" href="#mdp-init-lambda" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(-1)
starting value for lambda (float). Generally, this should only be
used with slow growth (<em>i.e.</em> nonzero <a class="reference internal" href="#mdp-delta-lambda"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">delta-lambda</span></code></a>). In
other cases, <a class="reference internal" href="#mdp-init-lambda-state"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">init-lambda-state</span></code></a> should be specified
instead. If a lambda vector is given, :mdp: <a class="reference internal" href="#mdp-init-lambda"><code class="xref any std std-mdp docutils literal notranslate"><span class="pre">init-lambda</span></code></a> is used to
interpolate the vector instead of setting lambda directly.
Must be greater than or equal to 0.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-delta-lambda">
<span class="sig-name descname"><span class="pre">delta-lambda</span></span><a class="headerlink" href="#mdp-delta-lambda" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0)
increment per time step for lambda</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-init-lambda-state">
<span class="sig-name descname"><span class="pre">init-lambda-state</span></span><a class="headerlink" href="#mdp-init-lambda-state" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(-1)
starting value for the lambda state (integer). Specifies which
columm of the lambda vector (<a class="reference internal" href="#mdp-coul-lambdas"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">coul-lambdas</span></code></a>,
<a class="reference internal" href="#mdp-vdw-lambdas"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">vdw-lambdas</span></code></a>, <a class="reference internal" href="#mdp-bonded-lambdas"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">bonded-lambdas</span></code></a>,
<a class="reference internal" href="#mdp-restraint-lambdas"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">restraint-lambdas</span></code></a>, <a class="reference internal" href="#mdp-mass-lambdas"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">mass-lambdas</span></code></a>,
<a class="reference internal" href="#mdp-temperature-lambdas"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">temperature-lambdas</span></code></a>, <a class="reference internal" href="#mdp-fep-lambdas"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">fep-lambdas</span></code></a>) should be
used. This is a zero-based index: <a class="reference internal" href="#mdp-init-lambda-state"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">init-lambda-state</span></code></a> 0 means
the first column, and so on.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-fep-lambdas">
<span class="sig-name descname"><span class="pre">fep-lambdas</span></span><a class="headerlink" href="#mdp-fep-lambdas" title="Permalink to this definition">Â¶</a></dt>
<dd><p>[array]
Zero, one or more lambda values for which Delta H values will be
determined and written to dhdl.xvg every <a class="reference internal" href="#mdp-nstdhdl"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstdhdl</span></code></a>
steps. Values must be greater than or equal to 0; values greater than
1 are allowed but should be used carefully. Free energy differences
between different lambda values can then be determined with
<a class="reference internal" href="../onlinehelp/gmx-bar.html#gmx-bar"><span class="std std-ref">gmx bar</span></a>. <a class="reference internal" href="#mdp-fep-lambdas"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">fep-lambdas</span></code></a> is different from the
other -lambdas keywords because all components of the lambda vector
that are not specified will use <a class="reference internal" href="#mdp-fep-lambdas"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">fep-lambdas</span></code></a> (including
<a class="reference internal" href="#mdp-restraint-lambdas"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">restraint-lambdas</span></code></a> and therefore the pull code restraints).</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-coul-lambdas">
<span class="sig-name descname"><span class="pre">coul-lambdas</span></span><a class="headerlink" href="#mdp-coul-lambdas" title="Permalink to this definition">Â¶</a></dt>
<dd><p>[array]
Zero, one or more lambda values for which Delta H values will be
determined and written to dhdl.xvg every <a class="reference internal" href="#mdp-nstdhdl"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstdhdl</span></code></a>
steps. Values must be greater than or equal to 0; values greater than
1 are allowed but should be used carefully. If soft-core potentials are
used, values must be between 0 and 1. Only the electrostatic
interactions are controlled with this component of the lambda
vector (and only if the lambda=0 and lambda=1 states have differing
electrostatic interactions).</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-vdw-lambdas">
<span class="sig-name descname"><span class="pre">vdw-lambdas</span></span><a class="headerlink" href="#mdp-vdw-lambdas" title="Permalink to this definition">Â¶</a></dt>
<dd><p>[array]
Zero, one or more lambda values for which Delta H values will be
determined and written to dhdl.xvg every <a class="reference internal" href="#mdp-nstdhdl"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstdhdl</span></code></a>
steps.  Values must be greater than or equal to 0; values greater than
1 are allowed but should be used carefully. If soft-core potentials are
used, values must be between 0 and 1. Only the van der Waals
interactions are controlled with this component of the lambda
vector.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-bonded-lambdas">
<span class="sig-name descname"><span class="pre">bonded-lambdas</span></span><a class="headerlink" href="#mdp-bonded-lambdas" title="Permalink to this definition">Â¶</a></dt>
<dd><p>[array]
Zero, one or more lambda values for which Delta H values will be
determined and written to dhdl.xvg every <a class="reference internal" href="#mdp-nstdhdl"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstdhdl</span></code></a>
steps.  Values must be greater than or equal to 0; values greater than
1 are allowed but should be used carefully. Only the bonded interactions
are controlled with this component of the lambda vector.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-restraint-lambdas">
<span class="sig-name descname"><span class="pre">restraint-lambdas</span></span><a class="headerlink" href="#mdp-restraint-lambdas" title="Permalink to this definition">Â¶</a></dt>
<dd><p>[array]
Zero, one or more lambda values for which Delta H values will be
determined and written to dhdl.xvg every <a class="reference internal" href="#mdp-nstdhdl"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstdhdl</span></code></a>
steps.  Values must be greater than or equal to 0; values greater than
1 are allowed but should be used carefully. Only the restraint
interactions: dihedral restraints, and the pull code restraints are
controlled with this component of the lambda vector.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-mass-lambdas">
<span class="sig-name descname"><span class="pre">mass-lambdas</span></span><a class="headerlink" href="#mdp-mass-lambdas" title="Permalink to this definition">Â¶</a></dt>
<dd><p>[array]
Zero, one or more lambda values for which Delta H values will be
determined and written to dhdl.xvg every <a class="reference internal" href="#mdp-nstdhdl"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstdhdl</span></code></a>
steps.  Values must be greater than or equal to 0; values greater than
1 are allowed but should be used carefully. Only the particle masses are
controlled with this component of the lambda vector.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-temperature-lambdas">
<span class="sig-name descname"><span class="pre">temperature-lambdas</span></span><a class="headerlink" href="#mdp-temperature-lambdas" title="Permalink to this definition">Â¶</a></dt>
<dd><p>[array]
Zero, one or more lambda values for which Delta H values will be
determined and written to dhdl.xvg every <a class="reference internal" href="#mdp-nstdhdl"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstdhdl</span></code></a>
steps.  Values must be greater than or equal to 0; values greater than
1 are allowed but should be used carefully. Only the temperatures are
controlled with this component of the lambda vector. Note that
these lambdas should not be used for replica exchange, only for
simulated tempering.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-calc-lambda-neighbors">
<span class="sig-name descname"><span class="pre">calc-lambda-neighbors</span></span><a class="headerlink" href="#mdp-calc-lambda-neighbors" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1)
Controls the number of lambda values for which Delta H values will
be calculated and written out, if <a class="reference internal" href="#mdp-init-lambda-state"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">init-lambda-state</span></code></a> has
been set. A positive value will limit the number of lambda points
calculated to only the nth neighbors of <a class="reference internal" href="#mdp-init-lambda-state"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">init-lambda-state</span></code></a>:
for example, if <a class="reference internal" href="#mdp-init-lambda-state"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">init-lambda-state</span></code></a> is 5 and this parameter
has a value of 2, energies for lambda points 3-7 will be calculated
and writen out. A value of -1 means all lambda points will be
written out. For normal BAR such as with <a class="reference internal" href="../onlinehelp/gmx-bar.html#gmx-bar"><span class="std std-ref">gmx bar</span></a>, a value of
1 is sufficient, while for MBAR -1 should be used.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-sc-function">
<span class="sig-name descname"><span class="pre">sc-function</span></span><a class="headerlink" href="#mdp-sc-function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(beutler)</p>
<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-sc-function-beutler">
<span id="mdp-value-sc-function=beutler"></span><span class="sig-name descname"><span class="pre">beutler</span></span><a class="headerlink" href="#mdp-value-sc-function-beutler" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<p>Beutler <em>et al.</em> soft-core function</p>
<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-sc-function-gapsys">
<span id="mdp-value-sc-function=gapsys"></span><span class="sig-name descname"><span class="pre">gapsys</span></span><a class="headerlink" href="#mdp-value-sc-function-gapsys" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<p>Gapsys <em>et al.</em> soft-core function</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-sc-alpha">
<span class="sig-name descname"><span class="pre">sc-alpha</span></span><a class="headerlink" href="#mdp-sc-alpha" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0)
for <a class="reference internal" href="#mdp-value-sc-function-beutler"><code class="xref any std std-mdp-value docutils literal notranslate"><span class="pre">sc-function=beutler</span></code></a> the soft-core alpha parameter,
a value of 0 results in linear interpolation of the
LJ and Coulomb interactions.
Used only with <a class="reference internal" href="#mdp-value-sc-function-beutler"><code class="xref any std std-mdp-value docutils literal notranslate"><span class="pre">sc-function=beutler</span></code></a></p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-sc-r-power">
<span class="sig-name descname"><span class="pre">sc-r-power</span></span><a class="headerlink" href="#mdp-sc-r-power" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(6)
power 6 for the radial term in the soft-core equation.
Used only with <a class="reference internal" href="#mdp-value-sc-function-beutler"><code class="xref any std std-mdp-value docutils literal notranslate"><span class="pre">sc-function=beutler</span></code></a></p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-sc-coul">
<span class="sig-name descname"><span class="pre">sc-coul</span></span><a class="headerlink" href="#mdp-sc-coul" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(no)
Whether to apply the soft-core free energy interaction
transformation to the Columbic interaction of a molecule. Default
is no, as it is generally more efficient to turn off the Coulomic
interactions linearly before turning off the van der Waals
interactions. Note that it is only taken into account when lambda
states are used, not with <a class="reference internal" href="#mdp-couple-lambda0"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">couple-lambda0</span></code></a> /
<a class="reference internal" href="#mdp-couple-lambda1"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">couple-lambda1</span></code></a>, and you can still turn off soft-core
interactions by setting <a class="reference internal" href="#mdp-sc-alpha"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">sc-alpha</span></code></a> to 0.
Used only with <a class="reference internal" href="#mdp-value-sc-function-beutler"><code class="xref any std std-mdp-value docutils literal notranslate"><span class="pre">sc-function=beutler</span></code></a></p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-sc-power">
<span class="sig-name descname"><span class="pre">sc-power</span></span><a class="headerlink" href="#mdp-sc-power" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1)
the power for lambda in the soft-core function, only the values 1
and 2 are supported. Used only with <a class="reference internal" href="#mdp-value-sc-function-beutler"><code class="xref any std std-mdp-value docutils literal notranslate"><span class="pre">sc-function=beutler</span></code></a></p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-sc-sigma">
<span class="sig-name descname"><span class="pre">sc-sigma</span></span><a class="headerlink" href="#mdp-sc-sigma" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.3) [nm]
for <a class="reference internal" href="#mdp-value-sc-function-beutler"><code class="xref any std std-mdp-value docutils literal notranslate"><span class="pre">sc-function=beutler</span></code></a> the soft-core sigma for particles
which have a C6 or C12 parameter equal to zero or a sigma smaller
than <a class="reference internal" href="#mdp-sc-sigma"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">sc-sigma</span></code></a>.
Used only with <a class="reference internal" href="#mdp-value-sc-function-beutler"><code class="xref any std std-mdp-value docutils literal notranslate"><span class="pre">sc-function=beutler</span></code></a></p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-sc-gapsys-scale-linpoint-lj">
<span class="sig-name descname"><span class="pre">sc-gapsys-scale-linpoint-lj</span></span><a class="headerlink" href="#mdp-sc-gapsys-scale-linpoint-lj" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.85)
for <a class="reference internal" href="#mdp-value-sc-function-gapsys"><code class="xref any std std-mdp-value docutils literal notranslate"><span class="pre">sc-function=gapsys</span></code></a> it is the unitless alphaLJ parameter.
It controls the softness of the van der Waals interactions
by scaling the point for linearizing the vdw force.
Setting it to 0 will result in the standard hard-core
van der Waals interactions.
Used only with <a class="reference internal" href="#mdp-value-sc-function-gapsys"><code class="xref any std std-mdp-value docutils literal notranslate"><span class="pre">sc-function=gapsys</span></code></a></p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-sc-gapsys-scale-linpoint-q">
<span class="sig-name descname"><span class="pre">sc-gapsys-scale-linpoint-q</span></span><a class="headerlink" href="#mdp-sc-gapsys-scale-linpoint-q" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.3) [nm/e^2]
For <a class="reference internal" href="#mdp-value-sc-function-gapsys"><code class="xref any std std-mdp-value docutils literal notranslate"><span class="pre">sc-function=gapsys</span></code></a> the alphaQ parameter
with the unit of [nm/e^2] and default value of 0.3. It controls
the softness of the Coulombic interactions. Setting it to 0 will
result in the standard hard-core Coulombic interactions.
Used only with <a class="reference internal" href="#mdp-value-sc-function-gapsys"><code class="xref any std std-mdp-value docutils literal notranslate"><span class="pre">sc-function=gapsys</span></code></a></p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-sc-gapsys-sigma-lj">
<span class="sig-name descname"><span class="pre">sc-gapsys-sigma-lj</span></span><a class="headerlink" href="#mdp-sc-gapsys-sigma-lj" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.3) [nm]
for <a class="reference internal" href="#mdp-value-sc-function-gapsys"><code class="xref any std std-mdp-value docutils literal notranslate"><span class="pre">sc-function=gapsys</span></code></a> the soft-core sigma for particles
which have a C6 or C12 parameter equal to zero.
Used only with <a class="reference internal" href="#mdp-value-sc-function-gapsys"><code class="xref any std std-mdp-value docutils literal notranslate"><span class="pre">sc-function=gapsys</span></code></a></p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-couple-moltype">
<span class="sig-name descname"><span class="pre">couple-moltype</span></span><a class="headerlink" href="#mdp-couple-moltype" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Here one can supply a molecule type (as defined in the topology)
for calculating solvation or coupling free energies. There is a
special option <code class="docutils literal notranslate"><span class="pre">system</span></code> that couples all molecule types in the
system. This can be useful for equilibrating a system starting from
(nearly) random coordinates. <a class="reference internal" href="#mdp-free-energy"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">free-energy</span></code></a> has to be turned
on. The Van der Waals interactions and/or charges in this molecule
type can be turned on or off between lambda=0 and lambda=1,
depending on the settings of <a class="reference internal" href="#mdp-couple-lambda0"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">couple-lambda0</span></code></a> and
<a class="reference internal" href="#mdp-couple-lambda1"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">couple-lambda1</span></code></a>. If you want to decouple one of several
copies of a molecule, you need to copy and rename the molecule
definition in the topology.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-couple-lambda0">
<span class="sig-name descname"><span class="pre">couple-lambda0</span></span><a class="headerlink" href="#mdp-couple-lambda0" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-couple-lambda0-vdw-q">
<span id="mdp-value-couple-lambda0=vdw-q"></span><span class="sig-name descname"><span class="pre">vdw-q</span></span><a class="headerlink" href="#mdp-value-couple-lambda0-vdw-q" title="Permalink to this definition">Â¶</a></dt>
<dd><p>all interactions are on at lambda=0</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-couple-lambda0-vdw">
<span id="mdp-value-couple-lambda0=vdw"></span><span class="sig-name descname"><span class="pre">vdw</span></span><a class="headerlink" href="#mdp-value-couple-lambda0-vdw" title="Permalink to this definition">Â¶</a></dt>
<dd><p>the charges are zero (no Coulomb interactions) at lambda=0</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-couple-lambda0-q">
<span id="mdp-value-couple-lambda0=q"></span><span class="sig-name descname"><span class="pre">q</span></span><a class="headerlink" href="#mdp-value-couple-lambda0-q" title="Permalink to this definition">Â¶</a></dt>
<dd><p>the Van der Waals interactions are turned at lambda=0; soft-core
interactions will be required to avoid singularities</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-couple-lambda0-none">
<span id="mdp-value-couple-lambda0=none"></span><span class="sig-name descname"><span class="pre">none</span></span><a class="headerlink" href="#mdp-value-couple-lambda0-none" title="Permalink to this definition">Â¶</a></dt>
<dd><p>the Van der Waals interactions are turned off and the charges
are zero at lambda=0; soft-core interactions will be required to
avoid singularities.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-couple-lambda1">
<span class="sig-name descname"><span class="pre">couple-lambda1</span></span><a class="headerlink" href="#mdp-couple-lambda1" title="Permalink to this definition">Â¶</a></dt>
<dd><p>analogous to <a class="reference internal" href="#mdp-couple-lambda1"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">couple-lambda1</span></code></a>, but for lambda=1</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-couple-intramol">
<span class="sig-name descname"><span class="pre">couple-intramol</span></span><a class="headerlink" href="#mdp-couple-intramol" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-couple-intramol-no">
<span id="mdp-value-couple-intramol=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-couple-intramol-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>All intra-molecular non-bonded interactions for moleculetype
<a class="reference internal" href="#mdp-couple-moltype"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">couple-moltype</span></code></a> are replaced by exclusions and explicit
pair interactions. In this manner the decoupled state of the
molecule corresponds to the proper vacuum state without
periodicity effects.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-couple-intramol-yes">
<span id="mdp-value-couple-intramol=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-couple-intramol-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The intra-molecular Van der Waals and Coulomb interactions are
also turned on/off. This can be useful for partitioning
free-energies of relatively large molecules, where the
intra-molecular non-bonded interactions might lead to
kinetically trapped vacuum conformations. The 1-4 pair
interactions are not turned off.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nstdhdl">
<span class="sig-name descname"><span class="pre">nstdhdl</span></span><a class="headerlink" href="#mdp-nstdhdl" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(100)
the frequency for writing dH/dlambda and possibly Delta H to
dhdl.xvg, 0 means no ouput, should be a multiple of
<a class="reference internal" href="#mdp-nstcalcenergy"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstcalcenergy</span></code></a>.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-dhdl-derivatives">
<span class="sig-name descname"><span class="pre">dhdl-derivatives</span></span><a class="headerlink" href="#mdp-dhdl-derivatives" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(yes)</p>
<p>If yes (the default), the derivatives of the Hamiltonian with
respect to lambda at each <a class="reference internal" href="#mdp-nstdhdl"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstdhdl</span></code></a> step are written
out. These values are needed for interpolation of linear energy
differences with <a class="reference internal" href="../onlinehelp/gmx-bar.html#gmx-bar"><span class="std std-ref">gmx bar</span></a> (although the same can also be
achieved with the right foreign lambda setting, that may not be as
flexible), or with thermodynamic integration</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-dhdl-print-energy">
<span class="sig-name descname"><span class="pre">dhdl-print-energy</span></span><a class="headerlink" href="#mdp-dhdl-print-energy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(no)</p>
<p>Include either the total or the potential energy in the dhdl
file. Options are ânoâ, âpotentialâ, or âtotalâ. This information
is needed for later free energy analysis if the states of interest
are at different temperatures. If all states are at the same
temperature, this information is not needed. âpotentialâ is useful
in case one is using <code class="docutils literal notranslate"><span class="pre">mdrun</span> <span class="pre">-rerun</span></code> to generate the <code class="docutils literal notranslate"><span class="pre">dhdl.xvg</span></code>
file. When rerunning from an existing trajectory, the kinetic
energy will often not be correct, and thus one must compute the
residual free energy from the potential alone, with the kinetic
energy component computed analytically.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-separate-dhdl-file">
<span class="sig-name descname"><span class="pre">separate-dhdl-file</span></span><a class="headerlink" href="#mdp-separate-dhdl-file" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-separate-dhdl-file-yes">
<span id="mdp-value-separate-dhdl-file=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-separate-dhdl-file-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The free energy values that are calculated (as specified with
the foreign lambda and <a class="reference internal" href="#mdp-dhdl-derivatives"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">dhdl-derivatives</span></code></a> settings) are
written out to a separate file, with the default name
<code class="docutils literal notranslate"><span class="pre">dhdl.xvg</span></code>. This file can be used directly with <a class="reference internal" href="../onlinehelp/gmx-bar.html#gmx-bar"><span class="std std-ref">gmx bar</span></a>.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-separate-dhdl-file-no">
<span id="mdp-value-separate-dhdl-file=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-separate-dhdl-file-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The free energy values are written out to the energy output file
(<code class="docutils literal notranslate"><span class="pre">ener.edr</span></code>, in accumulated blocks at every <a class="reference internal" href="#mdp-nstenergy"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstenergy</span></code></a>
steps), where they can be extracted with <a class="reference internal" href="../onlinehelp/gmx-energy.html#gmx-energy"><span class="std std-ref">gmx energy</span></a> or
used directly with <a class="reference internal" href="../onlinehelp/gmx-bar.html#gmx-bar"><span class="std std-ref">gmx bar</span></a>.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-dh-hist-size">
<span class="sig-name descname"><span class="pre">dh-hist-size</span></span><a class="headerlink" href="#mdp-dh-hist-size" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0)
If nonzero, specifies the size of the histogram into which the
Delta H values (specified with foreign lambda) and the derivative
dH/dl values are binned, and written to ener.edr. This can be used
to save disk space while calculating free energy differences. One
histogram gets written for each foreign lambda and two for the
dH/dl, at every <a class="reference internal" href="#mdp-nstenergy"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstenergy</span></code></a> step. Be aware that incorrect
histogram settings (too small size or too wide bins) can introduce
errors. Do not use histograms unless youâre certain you need it.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-dh-hist-spacing">
<span class="sig-name descname"><span class="pre">dh-hist-spacing</span></span><a class="headerlink" href="#mdp-dh-hist-spacing" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.1)
Specifies the bin width of the histograms, in energy units. Used in
conjunction with <a class="reference internal" href="#mdp-dh-hist-size"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">dh-hist-size</span></code></a>. This size limits the
accuracy with which free energies can be calculated. Do not use
histograms unless youâre certain you need it.</p>
</dd></dl>

</section>
<section id="expanded-ensemble-calculations">
<h3>Expanded Ensemble calculations<a class="headerlink" href="#expanded-ensemble-calculations" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nstexpanded">
<span class="sig-name descname"><span class="pre">nstexpanded</span></span><a class="headerlink" href="#mdp-nstexpanded" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The number of integration steps beween attempted moves changing the
system Hamiltonian in expanded ensemble simulations. Must be a
multiple of <a class="reference internal" href="#mdp-nstcalcenergy"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstcalcenergy</span></code></a>, but can be greater or less than
<a class="reference internal" href="#mdp-nstdhdl"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">nstdhdl</span></code></a>.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-lmc-stats">
<span class="sig-name descname"><span class="pre">lmc-stats</span></span><a class="headerlink" href="#mdp-lmc-stats" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lmc-stats-no">
<span id="mdp-value-lmc-stats=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-lmc-stats-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>No Monte Carlo in state space is performed.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lmc-stats-metropolis-transition">
<span id="mdp-value-lmc-stats=metropolis-transition"></span><span class="sig-name descname"><span class="pre">metropolis-transition</span></span><a class="headerlink" href="#mdp-value-lmc-stats-metropolis-transition" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Uses the Metropolis weights to update the expanded ensemble
weight of each state. Min{1,exp(-(beta_new u_new - beta_old
u_old)}</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lmc-stats-barker-transition">
<span id="mdp-value-lmc-stats=barker-transition"></span><span class="sig-name descname"><span class="pre">barker-transition</span></span><a class="headerlink" href="#mdp-value-lmc-stats-barker-transition" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Uses the Barker transition critera to update the expanded
ensemble weight of each state i, defined by exp(-beta_new
u_new)/(exp(-beta_new u_new)+exp(-beta_old u_old))</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lmc-stats-wang-landau">
<span id="mdp-value-lmc-stats=wang-landau"></span><span class="sig-name descname"><span class="pre">wang-landau</span></span><a class="headerlink" href="#mdp-value-lmc-stats-wang-landau" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Uses the Wang-Landau algorithm (in state space, not energy
space) to update the expanded ensemble weights.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lmc-stats-min-variance">
<span id="mdp-value-lmc-stats=min-variance"></span><span class="sig-name descname"><span class="pre">min-variance</span></span><a class="headerlink" href="#mdp-value-lmc-stats-min-variance" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Uses the minimum variance updating method of Escobedo et al. to
update the expanded ensemble weights. Weights will not be the
free energies, but will rather emphasize states that need more
sampling to give even uncertainty.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-lmc-mc-move">
<span class="sig-name descname"><span class="pre">lmc-mc-move</span></span><a class="headerlink" href="#mdp-lmc-mc-move" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lmc-mc-move-no">
<span id="mdp-value-lmc-mc-move=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-lmc-mc-move-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>No Monte Carlo in state space is performed.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lmc-mc-move-metropolis-transition">
<span id="mdp-value-lmc-mc-move=metropolis-transition"></span><span class="sig-name descname"><span class="pre">metropolis-transition</span></span><a class="headerlink" href="#mdp-value-lmc-mc-move-metropolis-transition" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Randomly chooses a new state up or down, then uses the
Metropolis critera to decide whether to accept or reject:
Min{1,exp(-(beta_new u_new - beta_old u_old)}</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lmc-mc-move-barker-transition">
<span id="mdp-value-lmc-mc-move=barker-transition"></span><span class="sig-name descname"><span class="pre">barker-transition</span></span><a class="headerlink" href="#mdp-value-lmc-mc-move-barker-transition" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Randomly chooses a new state up or down, then uses the Barker
transition critera to decide whether to accept or reject:
exp(-beta_new u_new)/(exp(-beta_new u_new)+exp(-beta_old u_old))</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lmc-mc-move-gibbs">
<span id="mdp-value-lmc-mc-move=gibbs"></span><span class="sig-name descname"><span class="pre">gibbs</span></span><a class="headerlink" href="#mdp-value-lmc-mc-move-gibbs" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Uses the conditional weights of the state given the coordinate
(exp(-beta_i u_i) / sum_k exp(beta_i u_i) to decide which state
to move to.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lmc-mc-move-metropolized-gibbs">
<span id="mdp-value-lmc-mc-move=metropolized-gibbs"></span><span class="sig-name descname"><span class="pre">metropolized-gibbs</span></span><a class="headerlink" href="#mdp-value-lmc-mc-move-metropolized-gibbs" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Uses the conditional weights of the state given the coordinate
(exp(-beta_i u_i) / sum_k exp(beta_i u_i) to decide which state
to move to, EXCLUDING the current state, then uses a rejection
step to ensure detailed balance. Always more efficient that
Gibbs, though only marginally so in many situations, such as
when only the nearest neighbors have decent phase space
overlap.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-lmc-seed">
<span class="sig-name descname"><span class="pre">lmc-seed</span></span><a class="headerlink" href="#mdp-lmc-seed" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(-1)
random seed to use for Monte Carlo moves in state space. When
<a class="reference internal" href="#mdp-lmc-seed"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">lmc-seed</span></code></a> is set to -1, a pseudo random seed is us</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-mc-temperature">
<span class="sig-name descname"><span class="pre">mc-temperature</span></span><a class="headerlink" href="#mdp-mc-temperature" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Temperature used for acceptance/rejection for Monte Carlo moves. If
not specified, the temperature of the simulation specified in the
first group of <a class="reference internal" href="#mdp-ref-t"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">ref-t</span></code></a> is used.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-wl-ratio">
<span class="sig-name descname"><span class="pre">wl-ratio</span></span><a class="headerlink" href="#mdp-wl-ratio" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.8)
The cutoff for the histogram of state occupancies to be reset, and
the free energy incrementor to be changed from delta to delta *
<a class="reference internal" href="#mdp-wl-scale"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">wl-scale</span></code></a>. If we define the Nratio = (number of samples at
each histogram) / (average number of samples at each
histogram). <a class="reference internal" href="#mdp-wl-ratio"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">wl-ratio</span></code></a> of 0.8 means that means that the
histogram is only considered flat if all Nratio &gt; 0.8 AND
simultaneously all 1/Nratio &gt; 0.8.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-wl-scale">
<span class="sig-name descname"><span class="pre">wl-scale</span></span><a class="headerlink" href="#mdp-wl-scale" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.8)
Each time the histogram is considered flat, then the current value
of the Wang-Landau incrementor for the free energies is multiplied
by <a class="reference internal" href="#mdp-wl-scale"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">wl-scale</span></code></a>. Value must be between 0 and 1.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-init-wl-delta">
<span class="sig-name descname"><span class="pre">init-wl-delta</span></span><a class="headerlink" href="#mdp-init-wl-delta" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1.0)
The initial value of the Wang-Landau incrementor in kT. Some value
near 1 kT is usually most efficient, though sometimes a value of
2-3 in units of kT works better if the free energy differences are
large.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-wl-oneovert">
<span class="sig-name descname"><span class="pre">wl-oneovert</span></span><a class="headerlink" href="#mdp-wl-oneovert" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(no)
Set Wang-Landau incrementor to scale with 1/(simulation time) in
the large sample limit. There is significant evidence that the
standard Wang-Landau algorithms in state space presented here
result in free energies getting âburned inâ to incorrect values
that depend on the initial state. when <a class="reference internal" href="#mdp-wl-oneovert"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">wl-oneovert</span></code></a> is true,
then when the incrementor becomes less than 1/N, where N is the
mumber of samples collected (and thus proportional to the data
collection time, hence â1 over tâ), then the Wang-Lambda
incrementor is set to 1/N, decreasing every step. Once this occurs,
<a class="reference internal" href="#mdp-wl-ratio"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">wl-ratio</span></code></a> is ignored, but the weights will still stop
updating when the equilibration criteria set in
<a class="reference internal" href="#mdp-lmc-weights-equil"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">lmc-weights-equil</span></code></a> is achieved.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-lmc-repeats">
<span class="sig-name descname"><span class="pre">lmc-repeats</span></span><a class="headerlink" href="#mdp-lmc-repeats" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1)
Controls the number of times that each Monte Carlo swap type is
performed each iteration. In the limit of large numbers of Monte
Carlo repeats, then all methods converge to Gibbs sampling. The
value will generally not need to be different from 1.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-lmc-gibbsdelta">
<span class="sig-name descname"><span class="pre">lmc-gibbsdelta</span></span><a class="headerlink" href="#mdp-lmc-gibbsdelta" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(-1)
Limit Gibbs sampling to selected numbers of neighboring states. For
Gibbs sampling, it is sometimes inefficient to perform Gibbs
sampling over all of the states that are defined. A positive value
of <a class="reference internal" href="#mdp-lmc-gibbsdelta"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">lmc-gibbsdelta</span></code></a> means that only states plus or minus
<a class="reference internal" href="#mdp-lmc-gibbsdelta"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">lmc-gibbsdelta</span></code></a> are considered in exchanges up and down. A
value of -1 means that all states are considered. For less than 100
states, it is probably not that expensive to include all states.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-lmc-forced-nstart">
<span class="sig-name descname"><span class="pre">lmc-forced-nstart</span></span><a class="headerlink" href="#mdp-lmc-forced-nstart" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0)
Force initial state space sampling to generate weights. In order to
come up with reasonable initial weights, this setting allows the
simulation to drive from the initial to the final lambda state,
with <a class="reference internal" href="#mdp-lmc-forced-nstart"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">lmc-forced-nstart</span></code></a> steps at each state before moving on
to the next lambda state. If <a class="reference internal" href="#mdp-lmc-forced-nstart"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">lmc-forced-nstart</span></code></a> is
sufficiently long (thousands of steps, perhaps), then the weights
will be close to correct. However, in most cases, it is probably
better to simply run the standard weight equilibration algorithms.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-nst-transition-matrix">
<span class="sig-name descname"><span class="pre">nst-transition-matrix</span></span><a class="headerlink" href="#mdp-nst-transition-matrix" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(-1)
Frequency of outputting the expanded ensemble transition matrix. A
negative number means it will only be printed at the end of the
simulation.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-symmetrized-transition-matrix">
<span class="sig-name descname"><span class="pre">symmetrized-transition-matrix</span></span><a class="headerlink" href="#mdp-symmetrized-transition-matrix" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(no)
Whether to symmetrize the empirical transition matrix. In the
infinite limit the matrix will be symmetric, but will diverge with
statistical noise for short timescales. Forced symmetrization, by
using the matrix T_sym = 1/2 (T + transpose(T)), removes problems
like the existence of (small magnitude) negative eigenvalues.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-mininum-var-min">
<span class="sig-name descname"><span class="pre">mininum-var-min</span></span><a class="headerlink" href="#mdp-mininum-var-min" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(100)
The min-variance strategy (option of <a class="reference internal" href="#mdp-lmc-stats"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">lmc-stats</span></code></a> is only
valid for larger number of samples, and can get stuck if too few
samples are used at each state. <a class="reference internal" href="#mdp-mininum-var-min"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">mininum-var-min</span></code></a> is the
minimum number of samples that each state that are allowed before
the min-variance strategy is activated if selected.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-init-lambda-weights">
<span class="sig-name descname"><span class="pre">init-lambda-weights</span></span><a class="headerlink" href="#mdp-init-lambda-weights" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The initial weights (free energies) used for the expanded ensemble
states. Default is a vector of zero weights. format is similar to
the lambda vector settings in <a class="reference internal" href="#mdp-fep-lambdas"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">fep-lambdas</span></code></a>, except the
weights can be any floating point number. Units are kT. Its length
must match the lambda vector lengths.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-lmc-weights-equil">
<span class="sig-name descname"><span class="pre">lmc-weights-equil</span></span><a class="headerlink" href="#mdp-lmc-weights-equil" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lmc-weights-equil-no">
<span id="mdp-value-lmc-weights-equil=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-lmc-weights-equil-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Expanded ensemble weights continue to be updated throughout the
simulation.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lmc-weights-equil-yes">
<span id="mdp-value-lmc-weights-equil=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-lmc-weights-equil-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The input expanded ensemble weights are treated as equilibrated,
and are not updated throughout the simulation.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lmc-weights-equil-wl-delta">
<span id="mdp-value-lmc-weights-equil=wl-delta"></span><span class="sig-name descname"><span class="pre">wl-delta</span></span><a class="headerlink" href="#mdp-value-lmc-weights-equil-wl-delta" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Expanded ensemble weight updating is stopped when the
Wang-Landau incrementor falls below this value.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lmc-weights-equil-number-all-lambda">
<span id="mdp-value-lmc-weights-equil=number-all-lambda"></span><span class="sig-name descname"><span class="pre">number-all-lambda</span></span><a class="headerlink" href="#mdp-value-lmc-weights-equil-number-all-lambda" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Expanded ensemble weight updating is stopped when the number of
samples at all of the lambda states is greater than this value.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lmc-weights-equil-number-steps">
<span id="mdp-value-lmc-weights-equil=number-steps"></span><span class="sig-name descname"><span class="pre">number-steps</span></span><a class="headerlink" href="#mdp-value-lmc-weights-equil-number-steps" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Expanded ensemble weight updating is stopped when the number of
steps is greater than the level specified by this value.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lmc-weights-equil-number-samples">
<span id="mdp-value-lmc-weights-equil=number-samples"></span><span class="sig-name descname"><span class="pre">number-samples</span></span><a class="headerlink" href="#mdp-value-lmc-weights-equil-number-samples" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Expanded ensemble weight updating is stopped when the number of
total samples across all lambda states is greater than the level
specified by this value.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-lmc-weights-equil-count-ratio">
<span id="mdp-value-lmc-weights-equil=count-ratio"></span><span class="sig-name descname"><span class="pre">count-ratio</span></span><a class="headerlink" href="#mdp-value-lmc-weights-equil-count-ratio" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Expanded ensemble weight updating is stopped when the ratio of
samples at the least sampled lambda state and most sampled
lambda state greater than this value.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-simulated-tempering">
<span class="sig-name descname"><span class="pre">simulated-tempering</span></span><a class="headerlink" href="#mdp-simulated-tempering" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(no)
Turn simulated tempering on or off. Simulated tempering is
implemented as expanded ensemble sampling with different
temperatures instead of different Hamiltonians.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-sim-temp-low">
<span class="sig-name descname"><span class="pre">sim-temp-low</span></span><a class="headerlink" href="#mdp-sim-temp-low" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(300) [K]
Low temperature for simulated tempering.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-sim-temp-high">
<span class="sig-name descname"><span class="pre">sim-temp-high</span></span><a class="headerlink" href="#mdp-sim-temp-high" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(300) [K]
High temperature for simulated tempering.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-simulated-tempering-scaling">
<span class="sig-name descname"><span class="pre">simulated-tempering-scaling</span></span><a class="headerlink" href="#mdp-simulated-tempering-scaling" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Controls the way that the temperatures at intermediate lambdas are
calculated from the <a class="reference internal" href="#mdp-temperature-lambdas"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">temperature-lambdas</span></code></a> part of the lambda
vector.</p>
<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-simulated-tempering-scaling-linear">
<span id="mdp-value-simulated-tempering-scaling=linear"></span><span class="sig-name descname"><span class="pre">linear</span></span><a class="headerlink" href="#mdp-value-simulated-tempering-scaling-linear" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Linearly interpolates the temperatures using the values of
<a class="reference internal" href="#mdp-temperature-lambdas"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">temperature-lambdas</span></code></a>, <em>i.e.</em> if <a class="reference internal" href="#mdp-sim-temp-low"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">sim-temp-low</span></code></a>
=300, <a class="reference internal" href="#mdp-sim-temp-high"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">sim-temp-high</span></code></a> =400, then lambda=0.5 correspond to
a temperature of 350. A nonlinear set of temperatures can always
be implemented with uneven spacing in lambda.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-simulated-tempering-scaling-geometric">
<span id="mdp-value-simulated-tempering-scaling=geometric"></span><span class="sig-name descname"><span class="pre">geometric</span></span><a class="headerlink" href="#mdp-value-simulated-tempering-scaling-geometric" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Interpolates temperatures geometrically between
<a class="reference internal" href="#mdp-sim-temp-low"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">sim-temp-low</span></code></a> and <a class="reference internal" href="#mdp-sim-temp-high"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">sim-temp-high</span></code></a>. The i:th state
has temperature <a class="reference internal" href="#mdp-sim-temp-low"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">sim-temp-low</span></code></a> * (<a class="reference internal" href="#mdp-sim-temp-high"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">sim-temp-high</span></code></a> /
<a class="reference internal" href="#mdp-sim-temp-low"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">sim-temp-low</span></code></a>) raised to the power of
(i/(ntemps-1)). This should give roughly equal exchange for
constant heat capacity, though of course things simulations that
involve protein folding have very high heat capacity peaks.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-simulated-tempering-scaling-exponential">
<span id="mdp-value-simulated-tempering-scaling=exponential"></span><span class="sig-name descname"><span class="pre">exponential</span></span><a class="headerlink" href="#mdp-value-simulated-tempering-scaling-exponential" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Interpolates temperatures exponentially between
<a class="reference internal" href="#mdp-sim-temp-low"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">sim-temp-low</span></code></a> and <a class="reference internal" href="#mdp-sim-temp-high"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">sim-temp-high</span></code></a>. The i:th state
has temperature <a class="reference internal" href="#mdp-sim-temp-low"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">sim-temp-low</span></code></a> + (<a class="reference internal" href="#mdp-sim-temp-high"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">sim-temp-high</span></code></a> -
<a class="reference internal" href="#mdp-sim-temp-low"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">sim-temp-low</span></code></a>)*((exp(<a class="reference internal" href="#mdp-temperature-lambdas"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">temperature-lambdas</span></code></a>
(i))-1)/(exp(1.0)-i)).</p>
</dd></dl>

</dd></dl>

</section>
<section id="non-equilibrium-md">
<h3>Non-equilibrium MD<a class="headerlink" href="#non-equilibrium-md" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-acc-grps">
<span class="sig-name descname"><span class="pre">acc-grps</span></span><a class="headerlink" href="#mdp-acc-grps" title="Permalink to this definition">Â¶</a></dt>
<dd><p>groups for constant acceleration (<em>e.g.</em> <code class="docutils literal notranslate"><span class="pre">Protein</span> <span class="pre">Sol</span></code>) all atoms
in groups Protein and Sol will experience constant acceleration as
specified in the <a class="reference internal" href="#mdp-accelerate"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">accelerate</span></code></a> line. Note that the kinetic energy
of the center of mass of accelarated groups contributes to the kinetic
energy and temperature of the system. If this is not desired, make
each accelerate group also a separate temperature coupling group.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-accelerate">
<span class="sig-name descname"><span class="pre">accelerate</span></span><a class="headerlink" href="#mdp-accelerate" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [nm ps<sup>-2</sup>]
acceleration for <a class="reference internal" href="#mdp-acc-grps"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">acc-grps</span></code></a>; x, y and z for each group
(<em>e.g.</em> <code class="docutils literal notranslate"><span class="pre">0.1</span> <span class="pre">0.0</span> <span class="pre">0.0</span> <span class="pre">-0.1</span> <span class="pre">0.0</span> <span class="pre">0.0</span></code> means that first group has
constant acceleration of 0.1 nm ps<sup>-2</sup> in X direction, second group
the opposite).</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-freezegrps">
<span class="sig-name descname"><span class="pre">freezegrps</span></span><a class="headerlink" href="#mdp-freezegrps" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Groups that are to be frozen (<em>i.e.</em> their X, Y, and/or Z position
will not be updated; <em>e.g.</em> <code class="docutils literal notranslate"><span class="pre">Lipid</span> <span class="pre">SOL</span></code>). <a class="reference internal" href="#mdp-freezedim"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">freezedim</span></code></a>
specifies for which dimension(s) the freezing applies. To avoid
spurious contributions to the virial and pressure due to large
forces between completely frozen atoms you need to use energy group
exclusions, this also saves computing time. Note that coordinates
of frozen atoms are not scaled by pressure-coupling algorithms.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-freezedim">
<span class="sig-name descname"><span class="pre">freezedim</span></span><a class="headerlink" href="#mdp-freezedim" title="Permalink to this definition">Â¶</a></dt>
<dd><p>dimensions for which groups in <a class="reference internal" href="#mdp-freezegrps"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">freezegrps</span></code></a> should be frozen,
specify <code class="docutils literal notranslate"><span class="pre">Y</span></code> or <code class="docutils literal notranslate"><span class="pre">N</span></code> for X, Y and Z and for each group (<em>e.g.</em>
<code class="docutils literal notranslate"><span class="pre">Y</span> <span class="pre">Y</span> <span class="pre">N</span> <span class="pre">N</span> <span class="pre">N</span> <span class="pre">N</span></code> means that particles in the first group can move only in
Z direction. The particles in the second group can move in any
direction).</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-cos-acceleration">
<span class="sig-name descname"><span class="pre">cos-acceleration</span></span><a class="headerlink" href="#mdp-cos-acceleration" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0) [nm ps<sup>-2</sup>]
the amplitude of the acceleration profile for calculating the
viscosity. The acceleration is in the X-direction and the magnitude
is <a class="reference internal" href="#mdp-cos-acceleration"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">cos-acceleration</span></code></a> cos(2 pi z/boxheight). Two terms are
added to the energy file: the amplitude of the velocity profile and
1/viscosity.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-deform">
<span class="sig-name descname"><span class="pre">deform</span></span><a class="headerlink" href="#mdp-deform" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0 0 0 0 0 0) [nm ps<sup>-1</sup>]
The velocities of deformation for the box elements: a(x) b(y) c(z)
b(x) c(x) c(y). Each step the box elements for which <a class="reference internal" href="#mdp-deform"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">deform</span></code></a>
is non-zero are calculated as: box(ts)+(t-ts)*deform, off-diagonal
elements are corrected for periodicity. The coordinates are
transformed accordingly. Frozen degrees of freedom are (purposely)
also transformed. The time ts is set to t at the first step and at
steps at which x and v are written to trajectory to ensure exact
restarts. Deformation can be used together with semiisotropic or
anisotropic pressure coupling when the appropriate
compressibilities are set to zero. The diagonal elements can be
used to strain a solid. The off-diagonal elements can be used to
shear a solid or a liquid.</p>
</dd></dl>

</section>
<section id="electric-fields">
<h3>Electric fields<a class="headerlink" href="#electric-fields" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-electric-field-x">
<span class="sig-name descname"><span class="pre">electric-field-x</span></span><a class="headerlink" href="#mdp-electric-field-x" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-electric-field-y">
<span class="sig-name descname"><span class="pre">electric-field-y</span></span><a class="headerlink" href="#mdp-electric-field-y" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-electric-field-z">
<span class="sig-name descname"><span class="pre">electric-field-z</span></span><a class="headerlink" href="#mdp-electric-field-z" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Here you can specify an electric field that optionally can be
alternating and pulsed. The general expression for the field
has the form of a gaussian laser pulse:</p>
<div class="math notranslate nohighlight">
\[E(t) = E_0 \exp\left[-\frac{(t-t_0)^2}{2\sigma^2}\right]\cos\left[\omega (t-t_0)\right]\]</div>
<p>For example, the four parameters for direction x are set in the
fields of <a class="reference internal" href="#mdp-electric-field-x"><code class="xref std std-mdp docutils literal notranslate"><span class="pre">electric-field-x</span></code></a> (and similar for <code class="docutils literal notranslate"><span class="pre">electric-field-y</span></code>
and <code class="docutils literal notranslate"><span class="pre">electric-field-z</span></code>) like</p>
<p><code class="docutils literal notranslate"><span class="pre">electric-field-x</span>&#160; <span class="pre">=</span> <span class="pre">E0</span> <span class="pre">omega</span> <span class="pre">t0</span> <span class="pre">sigma</span></code></p>
<p>with units (respectively) V nm<sup>-1</sup>, ps<sup>-1</sup>, ps, ps.</p>
<p>In the special case that <code class="docutils literal notranslate"><span class="pre">sigma</span> <span class="pre">=</span> <span class="pre">0</span></code>, the exponential term is omitted
and only the cosine term is used. In this case, <code class="docutils literal notranslate"><span class="pre">t0</span></code> must be set to 0.
If also <code class="docutils literal notranslate"><span class="pre">omega</span> <span class="pre">=</span> <span class="pre">0</span></code> a static electric field is applied.</p>
<p>Read more at <a class="reference internal" href="../reference-manual/special/electric-fields.html#electric-fields"><span class="std std-ref">Electric fields</span></a> and in ref.Â <a class="reference internal" href="../reference-manual/references.html#refcaleman2008a"><span class="std std-ref">146</span></a>.</p>
</dd></dl>

</section>
<section id="mixed-quantum-classical-molecular-dynamics">
<h3>Mixed quantum/classical molecular dynamics<a class="headerlink" href="#mixed-quantum-classical-molecular-dynamics" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-QMMM-grps">
<span class="sig-name descname"><span class="pre">QMMM-grps</span></span><a class="headerlink" href="#mdp-QMMM-grps" title="Permalink to this definition">Â¶</a></dt>
<dd><p>groups to be descibed at the QM level for MiMiC QM/MM</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-QMMM">
<span class="sig-name descname"><span class="pre">QMMM</span></span><a class="headerlink" href="#mdp-QMMM" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-QMMM-no">
<span id="mdp-value-QMMM=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-QMMM-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>QM/MM is no longer supported via these .mdp options. For MiMic, use no here.</p>
</dd></dl>

</dd></dl>

</section>
<section id="computational-electrophysiology">
<h3>Computational Electrophysiology<a class="headerlink" href="#computational-electrophysiology" title="Permalink to this headline">Â¶</a></h3>
<p>Use these options to switch on and control ion/water position exchanges in âComputational
Electrophysiologyâ simulation setups. (See the <a class="reference external" href="../manual-2022.4.pdf">reference manual</a> for details).</p>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-swapcoords">
<span class="sig-name descname"><span class="pre">swapcoords</span></span><a class="headerlink" href="#mdp-swapcoords" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-swapcoords-no">
<span id="mdp-value-swapcoords=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-swapcoords-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Do not enable ion/water position exchanges.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-swapcoords-X-Y-Z">
<span id="mdp-value-swapcoords=X ; Y ; Z"></span><span class="sig-name descname"><span class="pre">X</span> <span class="pre">;</span> <span class="pre">Y</span> <span class="pre">;</span> <span class="pre">Z</span></span><a class="headerlink" href="#mdp-value-swapcoords-X-Y-Z" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Allow for ion/water position exchanges along the chosen direction.
In a typical setup with the membranes parallel to the x-y plane,
ion/water pairs need to be exchanged in Z direction to sustain the
requested ion concentrations in the compartments.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-swap-frequency">
<span class="sig-name descname"><span class="pre">swap-frequency</span></span><a class="headerlink" href="#mdp-swap-frequency" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1) The swap attempt frequency, i.e. every how many time steps the ion counts
per compartment are determined and exchanges made if necessary.
Normally it is not necessary to check at every time step.
For typical Computational Electrophysiology setups, a value of about 100 is
sufficient and yields a negligible performance impact.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-split-group0">
<span class="sig-name descname"><span class="pre">split-group0</span></span><a class="headerlink" href="#mdp-split-group0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Name of the index group of the membrane-embedded part of channel #0.
The center of mass of these atoms defines one of the compartment boundaries
and should be chosen such that it is near the center of the membrane.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-split-group1">
<span class="sig-name descname"><span class="pre">split-group1</span></span><a class="headerlink" href="#mdp-split-group1" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Channel #1 defines the position of the other compartment boundary.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-massw-split0">
<span class="sig-name descname"><span class="pre">massw-split0</span></span><a class="headerlink" href="#mdp-massw-split0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(no) Defines whether or not mass-weighting is used to calculate the split group center.</p>
<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-massw-split0-no">
<span id="mdp-value-massw-split0=no"></span><span class="sig-name descname"><span class="pre">no</span></span><a class="headerlink" href="#mdp-value-massw-split0-no" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Use the geometrical center.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-massw-split0-yes">
<span id="mdp-value-massw-split0=yes"></span><span class="sig-name descname"><span class="pre">yes</span></span><a class="headerlink" href="#mdp-value-massw-split0-yes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Use the center of mass.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-massw-split1">
<span class="sig-name descname"><span class="pre">massw-split1</span></span><a class="headerlink" href="#mdp-massw-split1" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(no) As above, but for split-group #1.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-solvent-group">
<span class="sig-name descname"><span class="pre">solvent-group</span></span><a class="headerlink" href="#mdp-solvent-group" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Name of the index group of solvent molecules.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-coupl-steps">
<span class="sig-name descname"><span class="pre">coupl-steps</span></span><a class="headerlink" href="#mdp-coupl-steps" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(10) Average the number of ions per compartment over these many swap attempt steps.
This can be used to prevent that ions near a compartment boundary
(diffusing through a channel, e.g.) lead to unwanted back and forth swaps.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-iontypes">
<span class="sig-name descname"><span class="pre">iontypes</span></span><a class="headerlink" href="#mdp-iontypes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1) The number of different ion types to be controlled. These are during the
simulation exchanged with solvent molecules to reach the desired reference numbers.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-iontype0-name">
<span class="sig-name descname"><span class="pre">iontype0-name</span></span><a class="headerlink" href="#mdp-iontype0-name" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Name of the first ion type.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-iontype0-in-A">
<span class="sig-name descname"><span class="pre">iontype0-in-A</span></span><a class="headerlink" href="#mdp-iontype0-in-A" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(-1) Requested (=reference) number of ions of type 0 in compartment A.
The default value of -1 means: use the number of ions as found in time step 0
as reference value.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-iontype0-in-B">
<span class="sig-name descname"><span class="pre">iontype0-in-B</span></span><a class="headerlink" href="#mdp-iontype0-in-B" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(-1) Reference number of ions of type 0 for compartment B.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-bulk-offsetA">
<span class="sig-name descname"><span class="pre">bulk-offsetA</span></span><a class="headerlink" href="#mdp-bulk-offsetA" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.0) Offset of the first swap layer from the compartment A midplane.
By default (i.e. bulk offset = 0.0), ion/water exchanges happen between layers
at maximum distance (= bulk concentration) to the split group layers. However,
an offset b (-1.0 &lt; b &lt; +1.0) can be specified to offset the bulk layer from the middle at 0.0
towards one of the compartment-partitioning layers (at +/- 1.0).</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-bulk-offsetB">
<span class="sig-name descname"><span class="pre">bulk-offsetB</span></span><a class="headerlink" href="#mdp-bulk-offsetB" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.0) Offset of the other swap layer from the compartment B midplane.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-threshold">
<span class="sig-name descname"><span class="pre">threshold</span></span><a class="headerlink" href="#mdp-threshold" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1) Only swap ions if threshold difference to requested count is reached.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-cyl0-r">
<span class="sig-name descname"><span class="pre">cyl0-r</span></span><a class="headerlink" href="#mdp-cyl0-r" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(2.0) [nm] Radius of the split cylinder #0.
Two split cylinders (mimicking the channel pores) can optionally be defined
relative to the center of the split group. With the help of these cylinders
it can be counted which ions have passed which channel. The split cylinder
definition has no impact on whether or not ion/water swaps are done.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-cyl0-up">
<span class="sig-name descname"><span class="pre">cyl0-up</span></span><a class="headerlink" href="#mdp-cyl0-up" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1.0) [nm] Upper extension of the split cylinder #0.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-cyl0-down">
<span class="sig-name descname"><span class="pre">cyl0-down</span></span><a class="headerlink" href="#mdp-cyl0-down" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1.0) [nm] Lower extension of the split cylinder #0.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-cyl1-r">
<span class="sig-name descname"><span class="pre">cyl1-r</span></span><a class="headerlink" href="#mdp-cyl1-r" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(2.0) [nm] Radius of the split cylinder #1.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-cyl1-up">
<span class="sig-name descname"><span class="pre">cyl1-up</span></span><a class="headerlink" href="#mdp-cyl1-up" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1.0) [nm] Upper extension of the split cylinder #1.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-cyl1-down">
<span class="sig-name descname"><span class="pre">cyl1-down</span></span><a class="headerlink" href="#mdp-cyl1-down" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1.0) [nm] Lower extension of the split cylinder #1.</p>
</dd></dl>

</section>
<section id="density-guided-simulations">
<h3>Density-guided simulations<a class="headerlink" href="#density-guided-simulations" title="Permalink to this headline">Â¶</a></h3>
<p>These options enable and control the calculation and application of additional
forces that are derived from three-dimensional densities, e.g., from cryo
electron-microscopy experiments. (See the <a class="reference external" href="../manual-2022.4.pdf">reference manual</a> for details)</p>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-density-guided-simulation-active">
<span class="sig-name descname"><span class="pre">density-guided-simulation-active</span></span><a class="headerlink" href="#mdp-density-guided-simulation-active" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(no) Activate density-guided simulations.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-density-guided-simulation-group">
<span class="sig-name descname"><span class="pre">density-guided-simulation-group</span></span><a class="headerlink" href="#mdp-density-guided-simulation-group" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(protein) The atoms that are subject to the forces from the density-guided
simulation and contribute to the simulated density.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-density-guided-simulation-similarity-measure">
<span class="sig-name descname"><span class="pre">density-guided-simulation-similarity-measure</span></span><a class="headerlink" href="#mdp-density-guided-simulation-similarity-measure" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(inner-product) Similarity measure between the density that is calculated
from the atom positions and the reference density.</p>
<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-density-guided-simulation-similarity-measure-inner-product">
<span id="mdp-value-density-guided-simulation-similarity-measure=inner-product"></span><span class="sig-name descname"><span class="pre">inner-product</span></span><a class="headerlink" href="#mdp-value-density-guided-simulation-similarity-measure-inner-product" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Takes the sum of the product of reference density and simulated density
voxel values.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-density-guided-simulation-similarity-measure-relative-entropy">
<span id="mdp-value-density-guided-simulation-similarity-measure=relative-entropy"></span><span class="sig-name descname"><span class="pre">relative-entropy</span></span><a class="headerlink" href="#mdp-value-density-guided-simulation-similarity-measure-relative-entropy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Uses the negative relative entropy (or Kullback-Leibler divergence)
between reference density and simulated density as similarity measure.
Negative density values are ignored.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-density-guided-simulation-similarity-measure-cross-correlation">
<span id="mdp-value-density-guided-simulation-similarity-measure=cross-correlation"></span><span class="sig-name descname"><span class="pre">cross-correlation</span></span><a class="headerlink" href="#mdp-value-density-guided-simulation-similarity-measure-cross-correlation" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Uses the Pearson correlation coefficient between reference density and
simulated density as similarity measure.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-density-guided-simulation-atom-spreading-weight">
<span class="sig-name descname"><span class="pre">density-guided-simulation-atom-spreading-weight</span></span><a class="headerlink" href="#mdp-density-guided-simulation-atom-spreading-weight" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(unity) Determines the multiplication factor for the Gaussian kernel when
spreading atoms on the grid.</p>
<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-density-guided-simulation-atom-spreading-weight-unity">
<span id="mdp-value-density-guided-simulation-atom-spreading-weight=unity"></span><span class="sig-name descname"><span class="pre">unity</span></span><a class="headerlink" href="#mdp-value-density-guided-simulation-atom-spreading-weight-unity" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Every atom in the density fitting group is assigned the same unit factor.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-density-guided-simulation-atom-spreading-weight-mass">
<span id="mdp-value-density-guided-simulation-atom-spreading-weight=mass"></span><span class="sig-name descname"><span class="pre">mass</span></span><a class="headerlink" href="#mdp-value-density-guided-simulation-atom-spreading-weight-mass" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Atoms contribute to the simulated density proportional to their mass.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-density-guided-simulation-atom-spreading-weight-charge">
<span id="mdp-value-density-guided-simulation-atom-spreading-weight=charge"></span><span class="sig-name descname"><span class="pre">charge</span></span><a class="headerlink" href="#mdp-value-density-guided-simulation-atom-spreading-weight-charge" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Atoms contribute to the simulated density proportional to their charge.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-density-guided-simulation-force-constant">
<span class="sig-name descname"><span class="pre">density-guided-simulation-force-constant</span></span><a class="headerlink" href="#mdp-density-guided-simulation-force-constant" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1e+09) [kJ mol<sup>-1</sup>] The scaling factor for density-guided simulation
forces. May also be negative.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-density-guided-simulation-gaussian-transform-spreading-width">
<span class="sig-name descname"><span class="pre">density-guided-simulation-gaussian-transform-spreading-width</span></span><a class="headerlink" href="#mdp-density-guided-simulation-gaussian-transform-spreading-width" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0.2) [nm] The Gaussian RMS width for the spread kernel for the simulated
density.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-density-guided-simulation-gaussian-transform-spreading-range-in-multiples-of-width">
<span class="sig-name descname"><span class="pre">density-guided-simulation-gaussian-transform-spreading-range-in-multiples-of-width</span></span><a class="headerlink" href="#mdp-density-guided-simulation-gaussian-transform-spreading-range-in-multiples-of-width" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(4) The range after which the gaussian is cut off in multiples of the Gaussian
RMS width described above.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-density-guided-simulation-reference-density-filename">
<span class="sig-name descname"><span class="pre">density-guided-simulation-reference-density-filename</span></span><a class="headerlink" href="#mdp-density-guided-simulation-reference-density-filename" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(reference.mrc) Reference density file name using an absolute path or a path
relative to the to the folder from which <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> is called.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-density-guided-simulation-nst">
<span class="sig-name descname"><span class="pre">density-guided-simulation-nst</span></span><a class="headerlink" href="#mdp-density-guided-simulation-nst" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1) Interval in steps at which the density fitting forces are evaluated
and applied. The forces are scaled by this number when applied (See the
<a class="reference external" href="../manual-2022.4.pdf">reference manual</a> for details).</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-density-guided-simulation-normalize-densities">
<span class="sig-name descname"><span class="pre">density-guided-simulation-normalize-densities</span></span><a class="headerlink" href="#mdp-density-guided-simulation-normalize-densities" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(true) Normalize the sum of density voxel values to one for the reference
density as well as the simulated density.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-density-guided-simulation-adaptive-force-scaling">
<span class="sig-name descname"><span class="pre">density-guided-simulation-adaptive-force-scaling</span></span><a class="headerlink" href="#mdp-density-guided-simulation-adaptive-force-scaling" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(false) Adapt the force constant to ensure a steady increase in similarity
between simulated and reference density.</p>
<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-density-guided-simulation-adaptive-force-scaling-true">
<span id="mdp-value-density-guided-simulation-adaptive-force-scaling=true"></span><span class="sig-name descname"><span class="pre">true</span></span><a class="headerlink" href="#mdp-value-density-guided-simulation-adaptive-force-scaling-true" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Use adaptive force scaling.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-density-guided-simulation-adaptive-force-scaling-time-constant">
<span class="sig-name descname"><span class="pre">density-guided-simulation-adaptive-force-scaling-time-constant</span></span><a class="headerlink" href="#mdp-density-guided-simulation-adaptive-force-scaling-time-constant" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(4) [ps] Couple force constant to increase in similarity with reference density
with this time constant. Larger times result in looser coupling.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-density-guided-simulation-shift-vector">
<span class="sig-name descname"><span class="pre">density-guided-simulation-shift-vector</span></span><a class="headerlink" href="#mdp-density-guided-simulation-shift-vector" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(0,0,0) [nm] Add this vector to all atoms in the
density-guided-simulation-group before calculating forces and energies for
density-guided-simulations. Affects only the density-guided-simulation forces
and energies. Corresponds to a shift of the input density in the opposite
direction by (-1) * density-guided-simulation-shift-vector.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-density-guided-simulation-transformation-matrix">
<span class="sig-name descname"><span class="pre">density-guided-simulation-transformation-matrix</span></span><a class="headerlink" href="#mdp-density-guided-simulation-transformation-matrix" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(1,0,0,0,1,0,0,0,1) Multiply all atoms with this matrix in the
density-guided-simulation-group before calculating forces and energies for
density-guided-simulations. Affects only the density-guided-simulation forces
and energies. Corresponds to a transformation of the input density by the
inverse of this matrix. The matrix is given in row-major order.
This option allows, e.g., rotation of the density-guided atom group around the
z-axis by <span class="math notranslate nohighlight">\(\theta\)</span> degress by using following input:
<span class="math notranslate nohighlight">\((\cos \theta , -\sin \theta , 0 , \sin \theta , \cos \theta , 0 , 0 , 0 , 1)\)</span> .</p>
</dd></dl>

</section>
<section id="qm-mm-simulations-with-cp2k-interface">
<h3>QM/MM simulations with CP2K Interface<a class="headerlink" href="#qm-mm-simulations-with-cp2k-interface" title="Permalink to this headline">Â¶</a></h3>
<p>These options enable and control the calculation and application of additional
QM/MM forces that are computed by the CP2K package if it is linked into GROMACS.
For further details about QM/MM interface implementation follow <a class="reference internal" href="../reference-manual/special/qmmm.html#qmmm"><span class="std std-ref">Hybrid Quantum-Classical simulations (QM/MM) with CP2K interface</span></a>.</p>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-qmmm-cp2k-active">
<span class="sig-name descname"><span class="pre">qmmm-cp2k-active</span></span><a class="headerlink" href="#mdp-qmmm-cp2k-active" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(false) Activate QM/MM simulations. Requires CP2K to be linked with GROMACS</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-qmmm-cp2k-qmgroup">
<span class="sig-name descname"><span class="pre">qmmm-cp2k-qmgroup</span></span><a class="headerlink" href="#mdp-qmmm-cp2k-qmgroup" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(System) Index group with atoms that are treated with QM.</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-qmmm-cp2k-qmmethod">
<span class="sig-name descname"><span class="pre">qmmm-cp2k-qmmethod</span></span><a class="headerlink" href="#mdp-qmmm-cp2k-qmmethod" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(PBE) Method used to describe the QM part of the system.</p>
<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-qmmm-cp2k-qmmethod-PBE">
<span id="mdp-value-qmmm-cp2k-qmmethod=PBE"></span><span class="sig-name descname"><span class="pre">PBE</span></span><a class="headerlink" href="#mdp-value-qmmm-cp2k-qmmethod-PBE" title="Permalink to this definition">Â¶</a></dt>
<dd><p>DFT using PBE functional and DZVP-MOLOPT basis set.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-qmmm-cp2k-qmmethod-BLYP">
<span id="mdp-value-qmmm-cp2k-qmmethod=BLYP"></span><span class="sig-name descname"><span class="pre">BLYP</span></span><a class="headerlink" href="#mdp-value-qmmm-cp2k-qmmethod-BLYP" title="Permalink to this definition">Â¶</a></dt>
<dd><p>DFT using BLYP functional and DZVP-MOLOPT basis set.</p>
</dd></dl>

<dl class="std mdp-value">
<dt class="sig sig-object std" id="mdp-value-qmmm-cp2k-qmmethod-INPUT">
<span id="mdp-value-qmmm-cp2k-qmmethod=INPUT"></span><span class="sig-name descname"><span class="pre">INPUT</span></span><a class="headerlink" href="#mdp-value-qmmm-cp2k-qmmethod-INPUT" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Provide an external input file for CP2K when running <a class="reference internal" href="../onlinehelp/gmx-grompp.html#gmx-grompp"><span class="std std-ref">gmx grompp</span></a> with the <code class="docutils literal notranslate"><span class="pre">-qmi</span></code> command-line option.
External input files are subject to the limitations that are described in <a class="reference internal" href="../reference-manual/special/qmmm.html#qmmm"><span class="std std-ref">Hybrid Quantum-Classical simulations (QM/MM) with CP2K interface</span></a>.</p>
</dd></dl>

</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-qmmm-cp2k-qmcharge">
<span class="sig-name descname"><span class="pre">qmmm-cp2k-qmcharge</span></span><a class="headerlink" href="#mdp-qmmm-cp2k-qmcharge" title="Permalink to this definition">Â¶</a></dt>
<dd><ol class="arabic simple" start="0">
<li><p>Total charge of the QM part.</p></li>
</ol>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-qmmm-cp2k-qmmultiplicity">
<span class="sig-name descname"><span class="pre">qmmm-cp2k-qmmultiplicity</span></span><a class="headerlink" href="#mdp-qmmm-cp2k-qmmultiplicity" title="Permalink to this definition">Â¶</a></dt>
<dd><ol class="arabic simple">
<li><p>Multiplicity or spin-state of QM part. Default value 1 means singlet state.</p></li>
</ol>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-qmmm-cp2k-qmfilenames">
<span class="sig-name descname"><span class="pre">qmmm-cp2k-qmfilenames</span></span><a class="headerlink" href="#mdp-qmmm-cp2k-qmfilenames" title="Permalink to this definition">Â¶</a></dt>
<dd><p>() Names of the CP2K files that will be generated during the simulation.
When using the default, empty, value the name of the simulation input file will be used
with an additional <code class="docutils literal notranslate"><span class="pre">_cp2k</span></code> suffix.</p>
</dd></dl>

</section>
<section id="user-defined-thingies">
<h3>User defined thingies<a class="headerlink" href="#user-defined-thingies" title="Permalink to this headline">Â¶</a></h3>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-user1-grps">
<span class="sig-name descname"><span class="pre">user1-grps</span></span><a class="headerlink" href="#mdp-user1-grps" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-user2-grps">
<span class="sig-name descname"><span class="pre">user2-grps</span></span><a class="headerlink" href="#mdp-user2-grps" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-userint1-0">
<span id="mdp-userint1 (0)"></span><span class="sig-name descname"><span class="pre">userint1</span> <span class="pre">(0)</span></span><a class="headerlink" href="#mdp-userint1-0" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-userint2-0">
<span id="mdp-userint2 (0)"></span><span class="sig-name descname"><span class="pre">userint2</span> <span class="pre">(0)</span></span><a class="headerlink" href="#mdp-userint2-0" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-userint3-0">
<span id="mdp-userint3 (0)"></span><span class="sig-name descname"><span class="pre">userint3</span> <span class="pre">(0)</span></span><a class="headerlink" href="#mdp-userint3-0" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-userint4-0">
<span id="mdp-userint4 (0)"></span><span class="sig-name descname"><span class="pre">userint4</span> <span class="pre">(0)</span></span><a class="headerlink" href="#mdp-userint4-0" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-userreal1-0">
<span id="mdp-userreal1 (0)"></span><span class="sig-name descname"><span class="pre">userreal1</span> <span class="pre">(0)</span></span><a class="headerlink" href="#mdp-userreal1-0" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-userreal2-0">
<span id="mdp-userreal2 (0)"></span><span class="sig-name descname"><span class="pre">userreal2</span> <span class="pre">(0)</span></span><a class="headerlink" href="#mdp-userreal2-0" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-userreal3-0">
<span id="mdp-userreal3 (0)"></span><span class="sig-name descname"><span class="pre">userreal3</span> <span class="pre">(0)</span></span><a class="headerlink" href="#mdp-userreal3-0" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-userreal4-0">
<span id="mdp-userreal4 (0)"></span><span class="sig-name descname"><span class="pre">userreal4</span> <span class="pre">(0)</span></span><a class="headerlink" href="#mdp-userreal4-0" title="Permalink to this definition">Â¶</a></dt>
<dd><p>These you can use if you modify code. You can pass integers and
reals and groups to your subroutine. Check the inputrec definition
in <code class="docutils literal notranslate"><span class="pre">src/gromacs/mdtypes/inputrec.h</span></code></p>
</dd></dl>

</section>
<section id="removed-features">
<h3>Removed features<a class="headerlink" href="#removed-features" title="Permalink to this headline">Â¶</a></h3>
<p>These features have been removed from GROMACS, but so that old
<a class="reference internal" href="../reference-manual/file-formats.html#mdp"><span class="std std-ref">mdp</span></a> and <a class="reference internal" href="../reference-manual/file-formats.html#tpr"><span class="std std-ref">tpr</span></a> files cannot be mistakenly misused, we still
parse this option. <a class="reference internal" href="../onlinehelp/gmx-grompp.html#gmx-grompp"><span class="std std-ref">gmx grompp</span></a> and <a class="reference internal" href="../onlinehelp/gmx-mdrun.html#gmx-mdrun"><span class="std std-ref">gmx mdrun</span></a> will issue a
fatal error if this is set.</p>
<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-adress">
<span class="sig-name descname"><span class="pre">adress</span></span><a class="headerlink" href="#mdp-adress" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(no)</p>
</dd></dl>

<dl class="std mdp">
<dt class="sig sig-object std" id="mdp-implicit-solvent">
<span class="sig-name descname"><span class="pre">implicit-solvent</span></span><a class="headerlink" href="#mdp-implicit-solvent" title="Permalink to this definition">Â¶</a></dt>
<dd><p>(no)</p>
</dd></dl>

</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Molecular dynamics parameters (.mdp options)</a><ul>
<li><a class="reference internal" href="#general-information">General information</a><ul>
<li><a class="reference internal" href="#preprocessing">Preprocessing</a></li>
<li><a class="reference internal" href="#run-control">Run control</a></li>
<li><a class="reference internal" href="#langevin-dynamics">Langevin dynamics</a></li>
<li><a class="reference internal" href="#energy-minimization">Energy minimization</a></li>
<li><a class="reference internal" href="#shell-molecular-dynamics">Shell Molecular Dynamics</a></li>
<li><a class="reference internal" href="#test-particle-insertion">Test particle insertion</a></li>
<li><a class="reference internal" href="#output-control">Output control</a></li>
<li><a class="reference internal" href="#neighbor-searching">Neighbor searching</a></li>
<li><a class="reference internal" href="#electrostatics">Electrostatics</a></li>
<li><a class="reference internal" href="#van-der-waals">Van der Waals</a></li>
<li><a class="reference internal" href="#tables">Tables</a></li>
<li><a class="reference internal" href="#ewald">Ewald</a></li>
<li><a class="reference internal" href="#temperature-coupling">Temperature coupling</a></li>
<li><a class="reference internal" href="#pressure-coupling">Pressure coupling</a></li>
<li><a class="reference internal" href="#simulated-annealing">Simulated annealing</a></li>
<li><a class="reference internal" href="#velocity-generation">Velocity generation</a></li>
<li><a class="reference internal" href="#bonds">Bonds</a></li>
<li><a class="reference internal" href="#energy-group-exclusions">Energy group exclusions</a></li>
<li><a class="reference internal" href="#walls">Walls</a></li>
<li><a class="reference internal" href="#com-pulling">COM pulling</a></li>
<li><a class="reference internal" href="#awh-adaptive-biasing">AWH adaptive biasing</a></li>
<li><a class="reference internal" href="#enforced-rotation">Enforced rotation</a></li>
<li><a class="reference internal" href="#nmr-refinement">NMR refinement</a></li>
<li><a class="reference internal" href="#free-energy-calculations">Free energy calculations</a></li>
<li><a class="reference internal" href="#expanded-ensemble-calculations">Expanded Ensemble calculations</a></li>
<li><a class="reference internal" href="#non-equilibrium-md">Non-equilibrium MD</a></li>
<li><a class="reference internal" href="#electric-fields">Electric fields</a></li>
<li><a class="reference internal" href="#mixed-quantum-classical-molecular-dynamics">Mixed quantum/classical molecular dynamics</a></li>
<li><a class="reference internal" href="#computational-electrophysiology">Computational Electrophysiology</a></li>
<li><a class="reference internal" href="#density-guided-simulations">Density-guided simulations</a></li>
<li><a class="reference internal" href="#qm-mm-simulations-with-cp2k-interface">QM/MM simulations with CP2K Interface</a></li>
<li><a class="reference internal" href="#user-defined-thingies">User defined thingies</a></li>
<li><a class="reference internal" href="#removed-features">Removed features</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="force-fields.html"
                        title="previous chapter">Force fields in GROMACS</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="mdrun-features.html"
                        title="next chapter">Useful mdrun features</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/user-guide/mdp-options.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="mdrun-features.html" title="Useful mdrun features"
             >next</a> |</li>
        <li class="right" >
          <a href="force-fields.html" title="Force fields in GROMACS"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">GROMACS 2022.4</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >User guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Molecular dynamics parameters (.mdp options)</a></li>
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, GROMACS development team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
  </body>
</html>